// Generated by CoffeeScript 2.5.1
(function() {
  var AUTOSKIPLIST_COUNT, Bottleneck, YOUTUBE_USER, autoPlayNext, autoskip, autoskipCount, autoskipList, autoskipTimeout, bodyParser, calcEntryStrings, calcLicensingInfo, calcOther, calcUserInfo, checkAutoskip, checkIfEveryoneLeft, companies, dashboardsRefreshNeeded, discordEnabled, discordIndex, echoEnabled, echoNewSong, entryFromArg, express, findMissingYoutubeInfo, fs, getColonTime, getLetterTime, getNickname, getTime, getUserFromNickname, getYoutubeData, history, https, isAnyoneCasting, isCasting, isPlaying, iso8601, lastPlayed, lastPlayedDuration, lastPlayedTime, lastPlayedTimeout, limiter, load, logAutoskip, logOutput, main, nicknames, nobodyWatchingTimeout, now, opinions, output, parseDuration, play, playNext, playingName, playlist, prettyDuration, privacyReplacer, queue, queueYoutubeTrending, refreshDashboards, refreshDashboardsIfNeeded, requestDashboardRefresh, run, sanitizeUsername, saveCompanies, saveNicknames, saveOpinions, savePlaylist, saveState, secrets, serverEpoch, sfwOnly, shouldSkip, sockets, someoneIsWatching, songEnding, songEndingTimeout, splitArtist, updateCasts, updateDiscord, updateNickname, updateNicknames, updateOpinion, updateOpinions, ytdl;

  Bottleneck = require('bottleneck');

  express = require('express');

  bodyParser = require('body-parser');

  iso8601 = require('iso8601-duration');

  fs = require('fs');

  https = require('https');

  ytdl = require('ytdl-core');

  YOUTUBE_USER = "YouTube";

  AUTOSKIPLIST_COUNT = 3;

  limiter = new Bottleneck({
    maxConcurrent: 5
  });

  now = function() {
    return Math.floor(Date.now() / 1000);
  };

  // TODO: Switch this sloppy pile of flat maps to a map of objects?
  serverEpoch = now();

  secrets = null;

  sockets = {};

  playlist = {};

  queue = [];

  history = [];

  output = [];

  lastPlayedTimeout = null;

  lastPlayedTime = now();

  lastPlayedDuration = 1;

  lastPlayed = null;

  songEndingTimeout = null;

  nobodyWatchingTimeout = null;

  isCasting = {};

  isPlaying = {};

  playingName = {};

  sfwOnly = {};

  opinions = {};

  dashboardsRefreshNeeded = false;

  discordEnabled = false;

  discordIndex = 0;

  autoskipCount = 0;

  autoskipTimeout = null;

  autoskipList = [];

  echoNewSong = false;

  echoEnabled = false;

  companies = {};

  nicknames = {};

  getNickname = function(user) {
    if (nicknames[user] != null) {
      return nicknames[user];
    }
    return user;
  };

  getUserFromNickname = function(nickname) {
    var n, u;
    for (u in nicknames) {
      n = nicknames[u];
      if (nickname === n) {
        return u;
      }
    }
    return nickname;
  };

  privacyReplacer = function(k, v) {
    if (k === 'user') {
      return void 0;
    }
    return v;
  };

  load = function() {
    var id, len, len1, loadedList, m, p, q, ref, ref1, state;
    if (fs.existsSync("playlist.json")) {
      loadedList = JSON.parse(fs.readFileSync("playlist.json", 'utf8'));
      playlist = {};
      for (id in loadedList) {
        p = loadedList[id];
        if (typeof p === 'boolean') {
          p = {
            id: id,
            user: 'Anonymous',
            start: -1,
            end: -1
          };
        }
        playlist[id] = p;
      }
    }
    if (fs.existsSync("state.json")) {
      state = JSON.parse(fs.readFileSync("state.json", 'utf8'));
      ref = state.queue;
      for (m = 0, len = ref.length; m < len; m++) {
        id = ref[m];
        if (playlist[id] != null) {
          queue.push(playlist[id]);
        }
      }
      ref1 = state.history;
      for (q = 0, len1 = ref1.length; q < len1; q++) {
        id = ref1[q];
        if (playlist[id] != null) {
          history.push(playlist[id]);
        }
      }
    }
    if (fs.existsSync("opinions.json")) {
      opinions = JSON.parse(fs.readFileSync("opinions.json", 'utf8'));
    }
    if (fs.existsSync("companies.json")) {
      companies = JSON.parse(fs.readFileSync("companies.json", 'utf8'));
    }
    if (fs.existsSync("nicknames.json")) {
      nicknames = JSON.parse(fs.readFileSync("nicknames.json", 'utf8'));
    }
  };

  savePlaylist = function() {
    return fs.writeFileSync("playlist.json", JSON.stringify(playlist, null, 2));
  };

  saveOpinions = function() {
    return fs.writeFileSync("opinions.json", JSON.stringify(opinions, null, 2));
  };

  saveCompanies = function() {
    return fs.writeFileSync("companies.json", JSON.stringify(companies, null, 2));
  };

  saveNicknames = function() {
    return fs.writeFileSync("nicknames.json", JSON.stringify(nicknames, null, 2));
  };

  logOutput = function(msg) {
    output.push(msg);
    while (output.length > 10) {
      output.shift();
    }
  };

  refreshDashboards = function() {
    var results, sid, soc;
    results = [];
    for (sid in sockets) {
      soc = sockets[sid];
      results.push(soc.emit('refresh', {}));
    }
    return results;
  };

  requestDashboardRefresh = function() {
    return dashboardsRefreshNeeded = true;
  };

  refreshDashboardsIfNeeded = function() {
    if (dashboardsRefreshNeeded) {
      // console.log "refreshDashboardsIfNeeded(): refreshing..."
      dashboardsRefreshNeeded = false;
      return refreshDashboards();
    }
  };

  saveState = function() {
    var e, len, len1, m, q, savedHistory, savedQueue, state;
    savedQueue = [];
    for (m = 0, len = queue.length; m < len; m++) {
      e = queue[m];
      savedQueue.push(e.id);
    }
    savedHistory = [];
    for (q = 0, len1 = history.length; q < len1; q++) {
      e = history[q];
      savedHistory.push(e.id);
    }
    state = {
      history: savedHistory,
      queue: savedQueue
    };
    fs.writeFileSync("state.json", JSON.stringify(state, null, 2));
    return console.log(`Saved State: (${savedQueue.length} in queue, ${savedHistory.length} in history)`);
  };

  isAnyoneCasting = function() {
    var sid, soc;
    for (sid in sockets) {
      soc = sockets[sid];
      if (isCasting[sid]) {
        return true;
      }
    }
    return false;
  };

  calcOther = function() {
    var count, n, names, other, props, sid, soc, user;
    names = [];
    count = 0;
    for (sid in sockets) {
      soc = sockets[sid];
      if (isPlaying[sid]) {
        count += 1;
      }
      if ((playingName[sid] != null) && playingName[sid].length > 0) {
        props = [];
        n = getNickname(playingName[sid]);
        user = getUserFromNickname(n);
        if (nicknames[user] != null) {
          props.push("Auto");
        }
        if (sfwOnly[sid]) {
          props.push("SFW");
        }
        if (props.length > 0) {
          n += ` (${props.join(", ")})`;
        }
        names.push(n);
      }
    }
    names.sort();
    other = {
      playing: count,
      names: names
    };
    return other;
  };

  updateCasts = function(id = null) {
    if (lastPlayed === null) {
      return;
    }
    if (!isAnyoneCasting()) {
      return;
    }
    return ytdl.getInfo(lastPlayed.id).then(function(info) {
      var available, results, sid, soc, url;
      available = ytdl.filterFormats(info.formats, 'audioandvideo');
      if (available.length > 0) {
        url = available[0].url;
        results = [];
        for (sid in sockets) {
          soc = sockets[sid];
          if ((id !== null) && (id !== sid)) {
            continue;
          }
          results.push(soc.emit('cast', {
            url: url,
            start: lastPlayed.start
          }));
        }
        return results;
      }
    });
  };

  updateDiscord = function() {
    var index;
    if (!discordEnabled || (lastPlayed == null)) {
      return;
    }
    index = discordIndex;
    discordIndex = (discordIndex + 1) % secrets.discordTokens.length;
    return (function(index) {
      var discordPath, discordPrefix, options, postData, req;
      discordPath = `/api/channels/${secrets.discordChannel}`;
      discordPrefix = secrets.discordPrefix;
      if (discordPrefix == null) {
        discordPrefix = "";
      }
      postData = JSON.stringify({
        topic: `${discordPrefix}${lastPlayed.title}`
      });
      options = {
        hostname: 'discord.com',
        port: 443,
        path: discordPath,
        method: 'PATCH',
        headers: {
          'Authorization': `Bot ${secrets.discordTokens[index]}`,
          'Content-Type': 'application/json',
          'Content-Length': postData.length
        }
      };
      // console.log JSON.stringify(options, null, 2)
      req = https.request(options, function(res) {
        var reply, statusCode;
        statusCode = res.statusCode;
        reply = "";
        res.on('data', function(d) {
          return reply += String(d);
        });
        return res.on('end', function(d) {
          if (statusCode === 200) {
            reply = "OK";
          }
          return console.log(`Discord[${index}] Reply [${statusCode}]: ${reply}`);
        });
      });
      req.on('error', function(error) {
        return console.error(`Discord[${index}] Error: ${error}`);
      });
      console.log(`Discord[${index}] PATCH ${discordPath}: ${postData}`);
      req.write(postData);
      return req.end();
    })(index);
  };

  logAutoskip = function() {
    var l;
    if (autoskipCount > 0) {
      l = autoskipList.join(", ");
      if (autoskipCount > AUTOSKIPLIST_COUNT) {
        l += `, +${autoskipCount - AUTOSKIPLIST_COUNT} more`;
      }
      logOutput(`MTV: Auto-skipped ${autoskipCount} song${autoskipCount === 1 ? "" : "s"}: \`${l}\``);
    }
    autoskipCount = 0;
    autoskipList = [];
  };

  shouldSkip = function(e) {
    var feeling, ref, sid, skipIt, soc, user;
    console.log(`shouldSkip: e ${JSON.stringify(e)}`);
    if (e.nsfw) {
// console.log "shouldSkip: sfwOnly #{JSON.stringify(sfwOnly)}"
      for (sid in sockets) {
        soc = sockets[sid];
        if (!isPlaying[sid]) {
          continue;
        }
        if (sfwOnly[sid]) {
          console.log(`autoskip: ${playingName[sid]} can't watch NSFW content, bailing out.`);
          return true;
        }
      }
    }
    skipIt = false;
    for (sid in sockets) {
      soc = sockets[sid];
      if (!isPlaying[sid]) {
        continue;
      }
      if (playingName[sid] != null) {
        if (nicknames[playingName[sid]] != null) {
          // This playingName has a nickname, it must be the user
          user = playingName[sid];
        } else {
          user = getUserFromNickname(playingName[sid]);
          if (user === playingName[sid]) {
            // The nickname provided doesn't map to ID we know, skip them
            continue;
          }
        }
        feeling = (ref = opinions[e.id]) != null ? ref[user] : void 0;
        if (feeling == null) {
          console.log(`autoskip: ${user} has no opinion of this song, bailing out.`);
          return false;
        }
        if (feeling === 'like') {
          console.log(`autoskip: ${user} likes this song, bailing out.`);
          return false;
        }
        if (feeling === 'meh') {
          console.log(`autoskip: ${user} mehs this song, bailing out.`);
          return false;
        }
        // any other feeling is autoskip-worthy
        skipIt = true;
      }
    }
    return skipIt;
  };

  autoskip = function() {
    var strs;
    if (lastPlayed === null) {
      console.log("autoskip: lastPlayed is null.");
      return;
    }
    if (shouldSkip(lastPlayed)) {
      strs = calcEntryStrings(lastPlayed);
      console.log(`autoskip: Autoskipped ${strs.description}`);
      if (autoskipTimeout != null) {
        clearTimeout(autoskipTimeout);
        autoskipTimeout = null;
      }
      autoskipTimeout = setTimeout(logAutoskip, 1000);
      autoskipCount += 1;
      if (autoskipCount <= AUTOSKIPLIST_COUNT) {
        autoskipList.push(`${strs.artist} - ${strs.title}`);
      }
      playNext();
      return;
    }
    console.log("autoskip: Nothing to do.");
    if (echoEnabled && echoNewSong) {
      echoNewSong = false;
      strs = calcEntryStrings(lastPlayed);
      logOutput(`MTV: Playing: ${strs.description}`);
    }
  };

  checkAutoskip = function() {
    return setTimeout(function() {
      return autoskip();
    }, 0);
  };

  songEnding = function() {
    var pkt, results, socket, socketId, strs;
    if (lastPlayed == null) {
      return;
    }
    strs = calcEntryStrings(lastPlayed);
    results = [];
    for (socketId in sockets) {
      socket = sockets[socketId];
      pkt = calcLicensingInfo(lastPlayed);
      results.push(socket.emit('ending', pkt));
    }
    return results;
  };

  someoneIsWatching = function() {
    var sid, soc, someoneWatching;
    someoneWatching = false;
    for (sid in sockets) {
      soc = sockets[sid];
      if (isPlaying[sid]) {
        someoneWatching = true;
        break;
      }
    }
    return someoneWatching;
  };

  checkIfEveryoneLeft = function() {
    if (nobodyWatchingTimeout != null) {
      return;
    }
    if (!someoneIsWatching()) {
      return nobodyWatchingTimeout = setTimeout(function() {
        if (echoEnabled) {
          echoEnabled = false;
          logOutput("MTV: Auto-disabling echo (everyone left)");
        }
        return nobodyWatchingTimeout = null;
      }, 15000);
    }
  };

  autoPlayNext = function() {
    var e;
    e = playNext();
    return console.log(`autoPlayNext: ${JSON.stringify(e, null, 2)}`);
  };

  play = function(e) {
    var endTime, pkt, socket, socketId, startTime;
    lastPlayedTime = now();
    lastPlayed = e;
    history.unshift(e);
    while (history.length > 20) {
      history.pop();
    }
    if (!shouldSkip(lastPlayed)) {
      pkt = calcLicensingInfo(e);
      pkt.id = e.id;
      pkt.start = e.start;
      pkt.end = e.end;
      for (socketId in sockets) {
        socket = sockets[socketId];
        socket.emit('play', pkt);
      }
      updateCasts();
      saveState();
      savePlaylist();
      updateDiscord();
    }
    console.log(`Playing: ${e.title} [${e.id}]`);
    startTime = e.start;
    if (startTime < 0) {
      startTime = 0;
    }
    endTime = e.end;
    if (endTime < 0) {
      endTime = e.duration;
    }
    lastPlayedDuration = endTime - startTime;
    if (lastPlayedDuration > e.duration) {
      lastPlayedDuration = e.duration - startTime;
    }
    // sanity check?
    if (lastPlayedDuration < 20) {
      lastPlayedDuration = e.duration;
    }
    if (lastPlayedTimeout != null) {
      clearTimeout(lastPlayedTimeout);
      lastPlayedTimeout = null;
    }
    lastPlayedTimeout = setTimeout(autoPlayNext, (lastPlayedDuration + 3) * 1000);
    if (songEndingTimeout != null) {
      clearTimeout(songEndingTimeout);
      songEndingTimeout = null;
    }
    if (lastPlayedDuration > 30) {
      songEndingTimeout = setTimeout(songEnding, (lastPlayedDuration - 15) * 1000);
    }
    console.log(`Play: [${e.title}] [${lastPlayedDuration} seconds]`);
    echoNewSong = true;
    checkAutoskip();
  };

  parseDuration = function(s) {
    return iso8601.toSeconds(iso8601.parse(s));
  };

  queueYoutubeTrending = function() {
    return new Promise(function(resolve, reject) {
      var req, url;
      url = `https://youtube.googleapis.com/youtube/v3/videos?part=snippet%2CcontentDetails%2Cstatistics&chart=mostPopular&maxResults=50&regionCode=US&videoCategoryId=10&key=${secrets.youtube}`;
      req = https.request(url, function(res) {
        var rawJSON;
        rawJSON = "";
        res.on('data', function(chunk) {
          return rawJSON += chunk;
        });
        res.on('error', function() {
          console.log("Error getting trending music");
          return resolve();
        });
        return res.on('end', function() {
          var chosenThumb, data, e, i, index, item, j, len, len1, len2, m, q, r, ref, ref1, saved, thumb, thumbType, thumbUrl, trendingQueue, unshuffledTrendingQueue;
          data = null;
          try {
            data = JSON.parse(rawJSON);
          } catch (error1) {
            console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
            return;
          }
          saved = false;
          if ((data.items != null) && (data.items.length > 0)) {
            unshuffledTrendingQueue = [];
            ref = data.items;
            for (m = 0, len = ref.length; m < len; m++) {
              item = ref[m];
              chosenThumb = null;
              ref1 = item.snippet.thumbnails;
              for (thumbType in ref1) {
                thumb = ref1[thumbType];
                if (chosenThumb == null) {
                  chosenThumb = thumb;
                  continue;
                }
                if (thumbType === 'medium') {
                  chosenThumb = thumb;
                  break;
                }
                if (chosenThumb.height < thumb.height) {
                  chosenThumb = thumb;
                }
              }
              thumbUrl = null;
              if (chosenThumb != null) {
                thumbUrl = chosenThumb.url;
              }
              if (thumbUrl == null) {
                thumbUrl = '/unknown.png';
              }
              e = entryFromArg(item.id);
              if (playlist[e.id] != null) {
                unshuffledTrendingQueue.push(playlist[e.id]);
              } else {
                e.title = item.snippet.title;
                e.thumb = thumbUrl;
                e.user = YOUTUBE_USER;
                e.duration = parseDuration(item.contentDetails.duration);
                unshuffledTrendingQueue.push(e);
              }
              console.log(`Found trending title [${e.id}]: ${e.title}`);
            }
            // savePlaylist()
            // saved = true
            trendingQueue = [unshuffledTrendingQueue.shift()];
            for (index = q = 0, len1 = unshuffledTrendingQueue.length; q < len1; index = ++q) {
              i = unshuffledTrendingQueue[index];
              j = Math.floor(Math.random() * (index + 1));
              trendingQueue.push(trendingQueue[j]);
              trendingQueue[j] = i;
            }
            for (r = 0, len2 = trendingQueue.length; r < len2; r++) {
              e = trendingQueue[r];
              queue.unshift(e);
            }
          }
          return resolve();
        });
      });
      return req.end();
    });
  };

  getYoutubeData = function(e) {
    return limiter.schedule(function() {
      e.id = e.id.replace(/\?.+$/, "");
      console.log(`Looking up: ${e.id}`);
      return new Promise(function(resolve, reject) {
        var req, url;
        url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&key=${secrets.youtube}&id=${e.id}`;
        req = https.request(url, function(res) {
          var rawJSON;
          rawJSON = "";
          res.on('data', function(chunk) {
            return rawJSON += chunk;
          });
          res.on('error', function() {
            console.log(`Error [${e.id}]`);
            return resolve();
          });
          return res.on('end', function() {
            var chosenThumb, data, ref, saved, thumb, thumbType, thumbUrl;
            data = null;
            try {
              data = JSON.parse(rawJSON);
            } catch (error1) {
              console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
              return;
            }
            console.log(`looking up ${e.id}`);
            saved = false;
            if ((data.items != null) && (data.items.length > 0)) {
              // console.log JSON.stringify(data, null, 2)
              if ((data.items[0].snippet != null) && (data.items[0].snippet.title != null) && (data.items[0].snippet.thumbnails != null) && (data.items[0].contentDetails.duration != null)) {
                chosenThumb = null;
                ref = data.items[0].snippet.thumbnails;
                for (thumbType in ref) {
                  thumb = ref[thumbType];
                  if (chosenThumb == null) {
                    chosenThumb = thumb;
                    continue;
                  }
                  if (thumbType === 'medium') {
                    chosenThumb = thumb;
                    break;
                  }
                  if (chosenThumb.height < thumb.height) {
                    chosenThumb = thumb;
                  }
                }
                thumbUrl = null;
                if (chosenThumb != null) {
                  thumbUrl = chosenThumb.url;
                }
                if (thumbUrl == null) {
                  thumbUrl = '/unknown.png';
                }
                e.title = data.items[0].snippet.title;
                e.thumb = thumbUrl;
                e.duration = parseDuration(data.items[0].contentDetails.duration);
                splitArtist(e);
                console.log(`Found title [${e.id}]: '${e.artist}' - '${e.title}'`);
                savePlaylist();
                saved = true;
              }
            }
            if (!saved) {
              console.log(`Nope [${e.id}]`);
            }
            return resolve();
          });
        });
        return req.end();
      });
    });
  };

  playNext = function() {
    var e, i, index, j, k, len, m, unshuffled, v;
    if (queue.length < 1) {
      unshuffled = [];
      for (k in playlist) {
        v = playlist[k];
        unshuffled.push(v);
      }
      if (unshuffled.length > 0) {
        queue = [unshuffled.shift()];
        for (index = m = 0, len = unshuffled.length; m < len; index = ++m) {
          i = unshuffled[index];
          j = Math.floor(Math.random() * (index + 1));
          queue.push(queue[j]);
          queue[j] = i;
        }
      }
    }
    if (queue.length < 1) {
      console.log("Nothing to play!");
      return null;
    }
    e = queue.shift();
    console.log(e);
    play(e);
    return e;
  };

  // parses strings like 1h30m20s to seconds
  getLetterTime = function(timeString) {
    var i, m, ref, timePairs, timeValues, totalSeconds;
    totalSeconds = 0;
    timeValues = {
      's': 1,
      'm': 1 * 60,
      'h': 1 * 60 * 60,
      'd': 1 * 60 * 60 * 24,
      'w': 1 * 60 * 60 * 24 * 7
    };
    // expand to "1 h 30 m 20 s" and split
    timeString = timeString.replace(/([smhdw])/g, ' $1 ').trim();
    timePairs = timeString.split(' ');
    for (i = m = 0, ref = timePairs.length; m < ref; i = m += 2) {
      totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs[i + 1] || 's'];
    }
    return totalSeconds;
  };

  // parses strings like 1:30:20 to seconds
  getColonTime = function(timeString) {
    var i, m, ref, timePairs, timeValues, totalSeconds;
    totalSeconds = 0;
    timeValues = [1, 1 * 60, 1 * 60 * 60, 1 * 60 * 60 * 24, 1 * 60 * 60 * 24 * 7];
    timePairs = timeString.split(':');
    for (i = m = 0, ref = timePairs.length; (0 <= ref ? m < ref : m > ref); i = 0 <= ref ? ++m : --m) {
      totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs.length - i - 1];
    }
    return totalSeconds;
  };

  getTime = function(timeString) {
    if (timeString == null) {
      return 0;
    }
    if (timeString.match(/^(\d+[smhdw]?)+$/)) {
      return getLetterTime(timeString);
    }
    if (timeString.match(/^(\d+:?)+$/)) {
      return getColonTime(timeString);
    }
    return 0;
  };

  entryFromArg = function(arg) {
    var endTime, id, startTime, t, url, v;
    if (arg == null) {
      return null;
    }
    arg = String(arg);
    id = null;
    startTime = -1;
    endTime = -1;
    try {
      url = new URL(arg);
    } catch (error1) {
      url = null;
      id = arg;
    }
    if ((id == null) && (url.hostname === 'youtu.be')) {
      id = url.pathname.replace(/^\//, "");
    }
    if ((id == null) && url.hostname.match(/youtube.com$/)) {
      v = url.searchParams.get('v');
      if (v != null) {
        id = v;
      }
    }
    if (url != null) {
      t = url.searchParams.get('t');
      if (t != null) {
        startTime = getTime(t);
      }
      t = url.searchParams.get('start');
      if (t != null) {
        startTime = getTime(t);
      }
      t = url.searchParams.get('end');
      if (t != null) {
        endTime = getTime(t);
      }
    }
    if (id == null) {
      return null;
    }
    if (id.match(/\?/)) {
      return null;
    }
    return {
      id: id,
      start: startTime,
      end: endTime
    };
  };

  prettyDuration = function(duration) {
    var hours, minutes, str;
    str = "";
    hours = Math.floor(duration / 3600);
    if (hours > 0) {
      duration -= hours * 3600;
      str += `${hours}h`;
    }
    minutes = Math.floor(duration / 60);
    if (minutes > 0) {
      duration -= minutes * 60;
      str += `${minutes}m`;
    }
    if ((duration > 0) || (str.length === 0)) {
      str += `${duration}s`;
    }
    return str;
  };

  calcEntryStrings = function(e) {
    var actualDuration, artist, count, endTime, feeling, nick, nsfwString, opinionString, opinionTable, ownerNick, params, ref, ref1, startTime, title, url, user, userFeeling, whoList;
    url = `https://youtu.be/${e.id}`;
    params = "";
    if (e.start >= 0) {
      params += params.length === 0 ? "?" : "&";
      params += `start=${e.start}`;
    }
    if (e.end >= 0) {
      params += params.length === 0 ? "?" : "&";
      params += `end=${e.end}`;
    }
    if (e.title != null) {
      title = `${e.title} `;
    } else {
      title = " ";
    }
    if (e.artist != null) {
      artist = e.artist;
    } else {
      artist = "Unknown";
    }
    url = `${url}${params}`;
    startTime = e.start;
    if (startTime < 0) {
      startTime = 0;
    }
    endTime = e.end;
    if (endTime < 0) {
      endTime = e.duration;
    }
    actualDuration = endTime - startTime;
    opinionTable = {};
    opinionString = "";
    ref = e.opinions;
    for (feeling in ref) {
      count = ref[feeling];
      if (opinionTable[feeling] == null) {
        opinionTable[feeling] = [];
      }
      opinionString += `, ${count} ${feeling}${count === 1 ? "" : "s"}`;
      if ((opinions[e.id] != null) && (count > 0)) {
        whoList = [];
        ref1 = opinions[e.id];
        for (user in ref1) {
          userFeeling = ref1[user];
          if (feeling === userFeeling) {
            nick = getNickname(user);
            whoList.push(nick);
            opinionTable[feeling].push(nick);
          }
        }
        whoList.sort();
        opinionString += ` (${whoList.join(', ')})`;
      }
    }
    nsfwString = "";
    if (e.nsfw) {
      nsfwString = ", NSFW";
    }
    ownerNick = getNickname(e.user);
    return {
      artist: artist,
      title: title,
      opinions: opinionTable,
      url: url,
      description: `**${artist}** - **${title}** \`[${ownerNick}${nsfwString}, ${prettyDuration(actualDuration)}${opinionString}]\``
    };
  };

  calcLicensingInfo = function(e) {
    var company, nickname, strs;
    strs = calcEntryStrings(e);
    if (companies[e.user] != null) {
      company = companies[e.user];
    } else {
      nickname = getNickname(e.user);
      company = nickname.charAt(0).toUpperCase() + nickname.slice(1);
      company += " Records";
    }
    return {
      user: e.user,
      artist: strs.artist,
      title: strs.title,
      opinions: strs.opinions,
      company: company
    };
  };

  updateNickname = function(e) {
    e.nickname = getNickname(e.user);
  };

  updateNicknames = function(entries, isMap) {
    var e, k, len, m, v;
    if (isMap) {
      for (k in entries) {
        v = entries[k];
        updateNickname(v);
      }
    } else {
      for (m = 0, len = entries.length; m < len; m++) {
        e = entries[m];
        updateNickname(e);
      }
    }
  };

  updateOpinion = function(e) {
    var feeling, o, ref, user;
    o = {};
    if (opinions[e.id] != null) {
      ref = opinions[e.id];
      for (user in ref) {
        feeling = ref[user];
        if (o[feeling] == null) {
          o[feeling] = 0;
        }
        o[feeling] += 1;
      }
    }
    e.opinions = o;
  };

  updateOpinions = function(entries, isMap) {
    var e, k, len, m, v;
    if (isMap) {
      for (k in entries) {
        v = entries[k];
        updateOpinion(v);
      }
    } else {
      for (m = 0, len = entries.length; m < len; m++) {
        e = entries[m];
        updateOpinion(e);
      }
    }
  };

  calcUserInfo = function(user) {
    var base, base1, base2, base3, e, feeling, incoming, k, nickname, otherUser, outgoing, ref, userInfo;
    userInfo = {
      added: [],
      opinions: {},
      otherOpinions: {
        incoming: {},
        outgoing: {}
      },
      otherTotals: {
        incoming: {},
        outgoing: {}
      }
    };
    incoming = userInfo.otherOpinions.incoming;
    outgoing = userInfo.otherOpinions.outgoing;
    user = getUserFromNickname(user);
    for (k in playlist) {
      e = playlist[k];
      if (e.user === user) {
        userInfo.added.push(e);
        if (opinions[e.id] != null) {
          ref = opinions[e.id];
          for (otherUser in ref) {
            feeling = ref[otherUser];
            otherUser = getNickname(otherUser);
            if (incoming[otherUser] == null) {
              incoming[otherUser] = {};
            }
            if ((base = incoming[otherUser])[feeling] == null) {
              base[feeling] = 0;
            }
            incoming[otherUser][feeling] += 1;
            if ((base1 = userInfo.otherTotals.incoming)[feeling] == null) {
              base1[feeling] = 0;
            }
            userInfo.otherTotals.incoming[feeling] += 1;
          }
        }
      }
      if (opinions[e.id] != null) {
        if (opinions[e.id][user] != null) {
          feeling = opinions[e.id][user];
          if (userInfo.opinions[feeling] == null) {
            userInfo.opinions[feeling] = [];
          }
          userInfo.opinions[feeling].push(e);
          nickname = getNickname(e.user);
          if (outgoing[nickname] == null) {
            outgoing[nickname] = {};
          }
          if ((base2 = outgoing[nickname])[feeling] == null) {
            base2[feeling] = 0;
          }
          outgoing[nickname][feeling] += 1;
          if ((base3 = userInfo.otherTotals.outgoing)[feeling] == null) {
            base3[feeling] = 0;
          }
          userInfo.otherTotals.outgoing[feeling] += 1;
        }
      }
    }
    return userInfo;
  };

  run = async function(args, user) {
    var anonCount, cmd, companyArgs, concatenatedArgs, count, e, editArgs, extraSkips, i, len, m, name, name1, nameString, newCompany, newNickname, newValue, nicknameArgs, nsfw, oldValue, other, property, q, r, ref, ref1, ref2, ref3, ref4, ret, strs, title, w, x;
    cmd = 'who';
    if (args.length > 0) {
      cmd = args[0];
      cmd = cmd.replace(/^ +/, "");
      cmd = cmd.replace(/ +$/, "");
      if (cmd.length === 0) {
        cmd = 'who';
      }
    }
    // Sanitize command
    cmd = cmd.replace(/[^a-zA-Z0-9]/g, "");
    switch (cmd) {
      case 'help':
      case 'commands':
        return `MTV: Help: ${secrets.url}/help/`;
      case 'here':
      case 'watching':
      case 'web':
      case 'website':
        other = calcOther();
        nameString = "";
        if (other.playing === 0) {
          return "MTV: [Here] Nobody is watching.";
        }
        anonCount = other.playing - other.names.length;
        if (other.names.length > 0) {
          nameString = "";
          ref = other.names;
          for (m = 0, len = ref.length; m < len; m++) {
            name = ref[m];
            if (nameString.length > 0) {
              nameString += ", ";
            }
            nameString += `\`${name}\``;
          }
        }
        if (anonCount > 0) {
          if (nameString.length > 0) {
            nameString += " + ";
          }
          nameString += `**${anonCount}** anonymous`;
        }
        return `MTV: [Here] Watching: ${nameString}`;
      case 'what':
      case 'whatisthis':
      case 'who':
      case 'whodis':
      case 'why':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        strs = calcEntryStrings(lastPlayed);
        return `MTV: Playing: ${strs.description}`;
      case 'link':
      case 'url':
      case 'where':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        strs = calcEntryStrings(lastPlayed);
        return `MTV: ${strs.url}`;
      case 'like':
      case 'meh':
      case 'bleh':
      case 'hate':
      case 'none':
        e = null;
        if (args.length > 1) {
          if (args[1].toLowerCase() === 'last') {
            if (history.length < 2) {
              return "MTV [opinion]: Can't updated last song; no history.";
            }
            e = history[1];
          } else {
            e = entryFromArg(args[1]);
            if (e == null) {
              return `MTV [opinion]: I don't know what ${args[1]} is.`;
            }
          }
        }
        if (e == null) {
          if (lastPlayed === null) {
            return "MTV: I have no idea what's playing.";
          }
          e = lastPlayed;
        }
        if (playlist[e.id] == null) {
          return `MTV [opinion]: ${e.id} is not in the pool.`;
        }
        e = playlist[e.id];
        if (opinions[name1 = e.id] == null) {
          opinions[name1] = {};
        }
        if (cmd === 'none') {
          if (opinions[e.id][user] != null) {
            delete opinions[e.id][user];
          }
        } else {
          opinions[e.id][user] = cmd;
        }
        updateOpinion(e);
        strs = calcEntryStrings(e);
        saveOpinions();
        requestDashboardRefresh();
        checkAutoskip();
        return `MTV: Updated: ${strs.description}`;
      case 'echo':
        echoEnabled = !echoEnabled;
        return `MTV: Echo: ${echoEnabled}`;
      case 'nsfw':
      case 'sfw':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        nsfw = cmd === 'nsfw';
        lastPlayed.nsfw = nsfw;
        strs = calcEntryStrings(lastPlayed);
        savePlaylist();
        requestDashboardRefresh();
        checkAutoskip();
        return `MTV: (N)SFW Adjustment: ${strs.description}`;
      case 'add':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: add: invalid argument";
        }
        if (playlist[e.id] != null) {
          strs = calcEntryStrings(playlist[e.id]);
          return `MTV: Already in pool: ${strs.description}`;
        }
        e.user = user;
        playlist[e.id] = e;
        getYoutubeData(e);
        savePlaylist();
        return `MTV: Added to pool: ${e.id}`;
      case 'adopt':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        if (lastPlayed.user !== YOUTUBE_USER) {
          return `MTV: You may only adopt entries from ${YOUTUBE_USER}.`;
        }
        if (playlist[lastPlayed.id] != null) {
          strs = calcEntryStrings(playlist[lastPlayed.id]);
          return `MTV: Already in pool: ${strs.description}`;
        }
        lastPlayed.user = user;
        playlist[lastPlayed.id] = lastPlayed;
        savePlaylist();
        requestDashboardRefresh();
        return `MTV: Added to pool: ${lastPlayed.id}`;
      case 'edit':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: edit: invalid argument";
        }
        if (playlist[e.id] == null) {
          return "MTV: edit: Not in pool already, ignoring";
        }
        if (args.length < 3) {
          return "MTV: Syntax: edit [URL/id] [user/start/end/artist/title/nsfw/sfw] [newValue]";
        }
        property = args[2];
        editArgs = [];
        for (i = q = 3, ref1 = args.length; (3 <= ref1 ? q < ref1 : q > ref1); i = 3 <= ref1 ? ++q : --q) {
          editArgs.push(args[i]);
        }
        concatenatedArgs = editArgs.join(" ");
        switch (property) {
          case 'user':
            newValue = args[3];
            break;
          case 'start':
            newValue = parseInt(args[3]);
            if (isNaN(newValue)) {
              return `MTV: edit: invalid number ${args[3]}`;
            }
            if (newValue === 0) {
              newValue = -1;
            }
            break;
          case 'end':
            newValue = parseInt(args[3]);
            if (isNaN(newValue)) {
              return `MTV: edit: invalid number ${args[3]}`;
            }
            if (newValue >= playlist[e.id].duration) {
              newValue = -1;
            }
            break;
          case 'artist':
            newValue = concatenatedArgs;
            break;
          case 'title':
            newValue = concatenatedArgs;
            break;
          case 'sfw':
          case 'nsfw':
            newValue = property === 'nsfw';
            property = 'nsfw';
            break;
          default:
            return `MTV: edit: unknown property: ${property}`;
        }
        oldValue = playlist[e.id][property];
        playlist[e.id][property] = newValue;
        savePlaylist();
        requestDashboardRefresh();
        return `MTV: Edited: ${e.id} [${property}] \`${oldValue}\` -> \`${newValue}\``;
      case 'queue':
      case 'q':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: queue: invalid argument";
        }
        if (playlist[e.id] != null) {
          queue.unshift(playlist[e.id]);
          strs = calcEntryStrings(playlist[e.id]);
          ret = `MTV: Queued next (already in pool) ${strs.description}`;
        } else {
          e.user = user;
          playlist[e.id] = e;
          queue.unshift(playlist[e.id]);
          getYoutubeData(e);
          savePlaylist();
          ret = `MTV: Queued next and added to pool: ${e.id}`;
        }
        saveState();
        setTimeout(function() {
          return requestDashboardRefresh();
        }, 3000);
        return ret;
      case 'shuffle':
        queue = [];
        e = playNext();
        strs = calcEntryStrings(e);
        requestDashboardRefresh();
        return `MTV: Shuffled and playing a fresh song ${strs.description}`;
      case 'trending':
        await queueYoutubeTrending();
        e = playNext();
        strs = calcEntryStrings(e);
        requestDashboardRefresh();
        return `MTV: Queued up the top 50 trending music from youtube. First up: ${strs.description}`;
      case 'company':
      case 'label':
        companyArgs = [];
        for (i = r = 1, ref2 = args.length; (1 <= ref2 ? r < ref2 : r > ref2); i = 1 <= ref2 ? ++r : --r) {
          companyArgs.push(args[i]);
        }
        newCompany = companyArgs.join(" ");
        console.log(`newCompany: '${newCompany}'`);
        if (newCompany.match(/^\s*$/)) {
          return "MTV: Ignoring empty company name";
        }
        companies[user] = newCompany;
        saveCompanies();
        return `MTV: \`${user}\`'s new label: \`${newCompany}\``;
      case 'nickname':
      case 'name':
        nicknameArgs = [];
        for (i = w = 1, ref3 = args.length; (1 <= ref3 ? w < ref3 : w > ref3); i = 1 <= ref3 ? ++w : --w) {
          nicknameArgs.push(args[i]);
        }
        newNickname = nicknameArgs.join(" ");
        console.log(`newNickname: '${newNickname}'`);
        if (newNickname.match(/^\s*$/)) {
          return "MTV: Ignoring empty nickname";
        }
        nicknames[user] = newNickname;
        saveNicknames();
        requestDashboardRefresh();
        return `MTV: \`${user}\`'s new nickname: \`${newNickname}\``;
      case 'remove':
      case 'delete':
      case 'del':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: remove: invalid argument";
        }
        if (playlist[e.id] != null) {
          delete playlist[e.id];
          savePlaylist();
          title = e.title;
          if (title == null) {
            title = e.id;
          }
          return `MTV: Deleted ${title} from shuffled pool.`;
        } else {
          return `MTV: ${e.id} is already not in the shuffled pool.`;
        }
        break;
      case 'next':
      case 'skip':
        extraSkips = 0;
        if (args.length > 1) {
          count = parseInt(args[1]);
          if (count > 1) {
            extraSkips = count - 1;
          }
        }
        if (lastPlayed != null) {
          strs = calcEntryStrings(lastPlayed);
          ret = `MTV: Skipped ${strs.description}`;
        }
        for (i = x = 0, ref4 = extraSkips; (0 <= ref4 ? x < ref4 : x > ref4); i = 0 <= ref4 ? ++x : --x) {
          queue.shift();
        }
        e = playNext();
        if (ret == null) {
          ret = "MTV: Skipped unknown song";
        }
        return ret;
    }
    return `MTV: unknown command ${cmd}`;
  };

  splitArtist = function(e) {
    var artist, matches, title;
    if (e.artist != null) {
      return;
    }
    artist = "Unknown";
    title = e.title;
    if (matches = e.title.match(/^(.+)\s[–-]\s(.+)$/)) {
      artist = matches[1];
      title = matches[2];
    } else if (matches = e.title.match(/^([^"]+)\s"([^"]+)"/)) {
      artist = matches[1];
      title = matches[2];
    }
    title = title.replace(/[\(\[]Official(\sMusic)?\sVideo[\)\]]/i, "");
    title = title.replace(/^\s+/, "");
    title = title.replace(/\s+$/, "");
    if (title.match(/^".+"$/)) {
      title = title.replace(/^"/, "");
      title = title.replace(/"$/, "");
    }
    e.artist = artist;
    e.title = title;
    logOutput(`MTV: Calc[\`${e.id}\`] Artist: \`${e.artist}\`, Title: \`${e.title}\``);
  };

  findMissingYoutubeInfo = function() {
    var k, len, m, missingTitleCount, needsSave, v;
    console.log("Checking for missing Youtube info...");
    missingTitleCount = 0;
    needsSave = false;
    for (k in playlist) {
      v = playlist[k];
      if (playlist[k].countPlay != null) {
        delete playlist[k]["countPlay"];
        needsSave = true;
      }
      if (playlist[k].countSkip != null) {
        delete playlist[k]["countSkip"];
        needsSave = true;
      }
      if ((v.title == null) || (v.thumb == null) || (v.duration == null)) {
        getYoutubeData(v);
        missingTitleCount += 1;
      } else if (v.artist == null) {
        splitArtist(v);
        needsSave = true;
      }
    }
    for (m = 0, len = queue.length; m < len; m++) {
      v = queue[m];
      if (v.countPlay != null) {
        delete v["countPlay"];
        needsSave = true;
      }
      if (v.countSkip != null) {
        delete v["countSkip"];
        needsSave = true;
      }
      if ((v.title == null) || (v.thumb == null) || (v.duration == null)) {
        getYoutubeData(v);
        missingTitleCount += 1;
      } else if (v.artist == null) {
        splitArtist(v);
        needsSave = true;
      }
    }
    if (needsSave) {
      savePlaylist();
    }
    return console.log(`Found ${missingTitleCount} missing Youtube info.`);
  };

  sanitizeUsername = function(name) {
    if (name != null) {
      name = name.replace(/[^a-zA-Z0-9# ]/g, "");
      name = name.replace(/ +/g, " ");
      name = name.replace(/^ */, "");
      name = name.replace(/ *$/, "");
      if (name.length === 0) {
        return void 0;
      }
      name = name.substring(0, 16);
    }
    return name;
  };

  main = async function(argv) {
    var app, http, io;
    secrets = JSON.parse(fs.readFileSync('secrets.json', 'utf8'));
    if ((secrets.youtube == null) || (secrets.cmd == null)) {
      console.error("Bad secrets: " + JSON.stringify(secrets));
      return;
    }
    console.log("Secrets:");
    console.log(JSON.stringify(secrets, null, 2));
    load();
    if (secrets.discordTokens && secrets.discordChannel) {
      console.log("Discord enabled, logging in...");
      discordEnabled = true;
    } else {
      console.log("Discord disabled.");
    }
    await findMissingYoutubeInfo();
    setInterval(function() {
      return findMissingYoutubeInfo();
    }, 60 * 1000);
    setInterval(function() {
      return refreshDashboardsIfNeeded();
    }, 5 * 1000);
    // attempt to restart whatever was just playing
    if (history.length > 0) {
      queue.unshift(history.shift());
    }
    playNext();
    app = express();
    http = require('http').createServer(app);
    io = require('socket.io')(http);
    io.on('connection', function(socket) {
      sockets[socket.id] = socket;
      socket.emit('server', {
        epoch: serverEpoch
      });
      socket.on('playing', function(msg) {
        var needsRefresh, sfw, username;
        needsRefresh = false;
        if (!isPlaying[socket.id]) {
          isPlaying[socket.id] = true;
          needsRefresh = true;
          if (nobodyWatchingTimeout != null) {
            clearTimeout(nobodyWatchingTimeout);
            nobodyWatchingTimeout = null;
          }
        }
        username = sanitizeUsername(msg.user);
        if (playingName[socket.id] !== username) {
          if (username != null) {
            playingName[socket.id] = username;
          } else {
            delete playingName[socket.id];
          }
          needsRefresh = true;
        }
        sfw = false;
        // console.log "GOT MSG: #{JSON.stringify(msg)}"
        if ((msg.sfw != null) && ((msg.sfw === 'on') || (msg.sfw === '1') || (msg.sfw === 'true') || (msg.sfw === true))) {
          sfw = true;
        }
        if (sfwOnly[socket.id] !== sfw) {
          sfwOnly[socket.id] = sfw;
          needsRefresh = true;
        }
        if (needsRefresh) {
          return requestDashboardRefresh();
        }
      });
      socket.on('ready', function(msg) {
        var endTime, needsRefresh, pkt, sfw, startTime, username;
        // console.log "received ready"
        needsRefresh = false;
        if (!isPlaying[socket.id]) {
          isPlaying[socket.id] = true;
          needsRefresh = true;
          checkAutoskip();
        }
        username = sanitizeUsername(msg.user);
        if (playingName[socket.id] !== username) {
          if (username != null) {
            playingName[socket.id] = username;
          } else {
            delete playingName[socket.id];
          }
          needsRefresh = true;
        }
        sfw = false;
        // console.log "GOT MSG: #{JSON.stringify(msg)}"
        if ((msg.sfw != null) && ((msg.sfw === 'on') || (msg.sfw === '1') || (msg.sfw === 'true') || (msg.sfw === true))) {
          sfw = true;
        }
        if (sfwOnly[socket.id] !== sfw) {
          sfwOnly[socket.id] = sfw;
          needsRefresh = true;
        }
        if (needsRefresh) {
          requestDashboardRefresh();
        }
        if (lastPlayed != null) {
          // Give fresh watchers something to watch until the next song hits
          startTime = lastPlayed.start + (now() - lastPlayedTime);
          endTime = lastPlayed.end;
          if (endTime === -1) {
            endTime = lastPlayed.duration;
          }
          // console.log "endTime #{endTime} startTime #{startTime}"
          if ((endTime - startTime) > 5) {
            pkt = calcLicensingInfo(lastPlayed);
            pkt.id = lastPlayed.id;
            pkt.start = startTime;
            pkt.end = endTime;
            return socket.emit('play', pkt);
          }
        }
      });
      socket.on('disconnect', function() {
        if (sockets[socket.id] != null) {
          delete sockets[socket.id];
        }
        if (isCasting[socket.id] != null) {
          delete isCasting[socket.id];
        }
        if (playingName[socket.id] != null) {
          delete playingName[socket.id];
        }
        if (isPlaying[socket.id] != null) {
          delete isPlaying[socket.id];
          requestDashboardRefresh();
        }
        checkAutoskip();
        return checkIfEveryoneLeft();
      });
      return socket.on('castready', function(msg) {
        console.log("castready!");
        if (msg.id != null) {
          isCasting[msg.id] = true;
          return updateCasts(msg.id);
        }
      });
    });
    app.get('/', function(req, res) {
      var html;
      html = fs.readFileSync(`${__dirname}/../web/dashboard.html`, "utf8");
      return res.send(html);
    });
    app.get('/help', function(req, res) {
      var html;
      html = fs.readFileSync(`${__dirname}/../web/help.html`, "utf8");
      return res.send(html);
    });
    app.get('/stream', function(req, res) {
      var html;
      html = fs.readFileSync(`${__dirname}/../web/client.html`, "utf8");
      return res.send(html);
    });
    app.get('/watch', function(req, res) {
      var html;
      html = fs.readFileSync(`${__dirname}/../web/client.html`, "utf8");
      return res.send(html);
    });
    app.get('/info/playlist', function(req, res) {
      updateOpinions(playlist, true);
      updateNicknames(playlist, true);
      res.type('application/json');
      return res.send(JSON.stringify(playlist, privacyReplacer, 2));
    });
    app.get('/info/queue', function(req, res) {
      updateOpinions(queue);
      updateNicknames(queue);
      res.type('application/json');
      return res.send(JSON.stringify(queue, privacyReplacer, 2));
    });
    app.get('/info/history', function(req, res) {
      updateOpinions(history);
      updateNicknames(history);
      res.type('application/json');
      return res.send(JSON.stringify(history, privacyReplacer, 2));
    });
    app.get('/info/user', function(req, res) {
      var userInfo;
      if ((req.query != null) && (req.query.user != null)) {
        userInfo = calcUserInfo(req.query.user);
        res.type('application/json');
        return res.send(JSON.stringify(userInfo, privacyReplacer, 2));
      } else {
        return res.send("supply a user");
      }
    });
    app.get('/info/other', function(req, res) {
      var other;
      other = calcOther();
      res.type('application/json');
      return res.send(JSON.stringify(other, null, 2));
    });
    app.get('/info/output', function(req, res) {
      res.type('application/json');
      res.send(JSON.stringify(output, null, 2));
      if ((req.query != null) && (req.query.secret != null)) {
        if (req.query.secret === secrets.cmd) {
          return output = [];
        } else {
          return console.log("Bad secret, not clearing output array");
        }
      }
    });
    app.use(bodyParser.json());
    app.post('/cmd', async function(req, res) {
      var args, response, user;
      console.log(req.body);
      if ((req.body != null) && (req.body.cmd != null)) {
        if (req.body.secret !== secrets.cmd) {
          res.send("MTV: bad secret");
          return;
        }
        args = req.body.cmd.split(/\s+/g);
        user = req.body.user;
        if (user == null) {
          user = 'Anonymous';
        }
        response = (await run(args, user));
        console.log(`CMD: ${response}`);
        res.send(response);
        return;
      }
      return res.send("MTV: wat");
    });
    app.use(express.static('web'));
    return http.listen(3003, '127.0.0.1', function() {
      return console.log('listening on 127.0.0.1:3003');
    });
  };

  module.exports = main;

}).call(this);
