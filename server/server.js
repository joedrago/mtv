// Generated by CoffeeScript 2.5.1
(function() {
  var AUTOSKIPLIST_COUNT, Bottleneck, LOG_LEVELS, MAX_BLOCK_COUNT, YOUTUBE_USER, autoPlayNext, autoskip, autoskipCount, autoskipList, autoskipTimeout, bodyParser, calcEntryStrings, calcLicensingInfo, calcOther, calcUserInfo, calcUserOpinions, checkAutoskip, checkIfEveryoneLeft, companies, constants, convertYoutubePlaylist, dashboardsRefreshNeeded, discordAuth, discordEnabled, discordIndex, echoEnabled, echoNewSong, entryFromArg, express, filterObject, filters, findMissingYoutubeInfo, fs, getColonTime, getLetterTime, getNickname, getTime, getUserFromNickname, getYoutubeData, history, hosting, https, ignored, isOpinionCommand, isPlaying, iso8601, lastPlayed, lastPlayedDuration, lastPlayedTime, lastPlayedTimeout, limiter, load, logAutoskip, logOutput, logPlay, logger, main, nicknames, nobodyWatchingTimeout, now, opinions, output, pad, parseDuration, play, playNext, playingName, playlist, playlistIDFromArg, prettyDuration, privacyReplacer, processOAuth, queue, queueYoutubePlaylist, queueYoutubeTrending, randomShortString, randomString, refreshDashboards, refreshDashboardsIfNeeded, requestDashboardRefresh, run, sanitizeTag, sanitizeUsername, saveCompanies, saveDiscordAuth, saveIgnored, saveNicknames, saveOpinions, savePlaylist, saveState, saveUserPlaylists, secrets, serverEpoch, sfwOnly, shouldSkip, sockets, soloBroadcast, soloInfo, soloSessions, someoneIsWatchingWithAutoskip, songEnding, songEndingTimeout, splitArtist, trimAllWhitespace, updateNickname, updateNicknames, updateOpinion, updateOpinions, userPlaylists, winston, youtubeSoloRedirect, ytdl;

  Bottleneck = require('bottleneck');

  express = require('express');

  bodyParser = require('body-parser');

  iso8601 = require('iso8601-duration');

  fs = require('fs');

  https = require('https');

  ytdl = require('ytdl-core');

  winston = require('winston');

  require('winston-daily-rotate-file');

  constants = require('../constants');

  filters = require('../filters');

  hosting = require('./hosting');

  MAX_BLOCK_COUNT = 0;

  YOUTUBE_USER = "YouTube";

  AUTOSKIPLIST_COUNT = 3;

  // ------------------------------------------------------------------------------------------------
  // Logging
  LOG_LEVELS = {
    levels: {
      play: 0,
      error: 1,
      auth: 2,
      info: 3,
      all: 4
    },
    colors: {
      play: 'blue',
      error: 'red',
      auth: 'green',
      info: 'white',
      all: 'white'
    }
  };

  logger = winston.createLogger({
    levels: LOG_LEVELS.levels,
    transports: [
      new winston.transports.Console({
        level: 'all',
        format: winston.format.json()
      }),
      new winston.transports.DailyRotateFile({
        level: 'play',
        format: winston.format.json(),
        filename: 'play-%DATE%.log',
        datePattern: 'YYYY-MM',
        zippedArchive: true
      })
    ]
  });

  winston.addColors(LOG_LEVELS.colors);

  // ------------------------------------------------------------------------------------------------
  limiter = new Bottleneck({
    maxConcurrent: 5
  });

  now = function() {
    return Math.floor(Date.now() / 1000);
  };

  pad = function(s, count) {
    return ("                   " + s).slice(-1 * count);
  };

  randomString = function() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  };

  randomShortString = function() {
    return Math.random().toString(36).substring(2, 6).toLowerCase();
  };

  // TODO: Switch this sloppy pile of flat maps to a map of objects?
  serverEpoch = now();

  secrets = null;

  sockets = {};

  playlist = {};

  queue = [];

  history = [];

  output = [];

  lastPlayedTimeout = null;

  lastPlayedTime = now();

  lastPlayedDuration = 1;

  lastPlayed = null;

  songEndingTimeout = null;

  nobodyWatchingTimeout = null;

  isPlaying = {};

  playingName = {};

  sfwOnly = {};

  opinions = {};

  dashboardsRefreshNeeded = false;

  discordEnabled = false;

  discordIndex = 0;

  autoskipCount = 0;

  autoskipTimeout = null;

  autoskipList = [];

  userPlaylists = {};

  soloSessions = {};

  soloInfo = {};

  echoNewSong = false;

  echoEnabled = false;

  companies = {};

  nicknames = {};

  ignored = {};

  discordAuth = {};

  getNickname = function(user) {
    if (nicknames[user] != null) {
      return nicknames[user];
    }
    return user;
  };

  getUserFromNickname = function(nickname) {
    var n, u;
    for (u in nicknames) {
      n = nicknames[u];
      if (nickname === n) {
        return u;
      }
    }
    return nickname;
  };

  privacyReplacer = function(k, v) {
    if (k === 'user') {
      return void 0;
    }
    return v;
  };

  sanitizeTag = function(tagName) {
    tagName = tagName.toLowerCase();
    tagName = tagName.replace(/[^-_a-z0-9]/g, "");
    return tagName;
  };

  load = function() {
    var id, len, len1, loadedList, m, p, q, ref, ref1, state;
    if (fs.existsSync("playlist.json")) {
      loadedList = JSON.parse(fs.readFileSync("playlist.json", 'utf8'));
      playlist = {};
      for (id in loadedList) {
        p = loadedList[id];
        if (typeof p === 'boolean') {
          p = {
            id: id,
            user: 'Anonymous',
            start: -1,
            end: -1
          };
        }
        playlist[id] = p;
      }
    }
    if (fs.existsSync("state.json")) {
      state = JSON.parse(fs.readFileSync("state.json", 'utf8'));
      ref = state.queue;
      for (m = 0, len = ref.length; m < len; m++) {
        id = ref[m];
        if (playlist[id] != null) {
          queue.push(playlist[id]);
        }
      }
      ref1 = state.history;
      for (q = 0, len1 = ref1.length; q < len1; q++) {
        id = ref1[q];
        if (playlist[id] != null) {
          history.push(playlist[id]);
        }
      }
    }
    if (fs.existsSync("opinions.json")) {
      opinions = JSON.parse(fs.readFileSync("opinions.json", 'utf8'));
    }
    if (fs.existsSync("companies.json")) {
      companies = JSON.parse(fs.readFileSync("companies.json", 'utf8'));
    }
    if (fs.existsSync("nicknames.json")) {
      nicknames = JSON.parse(fs.readFileSync("nicknames.json", 'utf8'));
    }
    if (fs.existsSync("ignored.json")) {
      ignored = JSON.parse(fs.readFileSync("ignored.json", 'utf8'));
    }
    if (fs.existsSync("auth.json")) {
      discordAuth = JSON.parse(fs.readFileSync("auth.json", 'utf8'));
    }
    if (fs.existsSync("userplaylists.json")) {
      userPlaylists = JSON.parse(fs.readFileSync("userplaylists.json", 'utf8'));
    }
  };

  savePlaylist = function() {
    return fs.writeFileSync("playlist.json", JSON.stringify(playlist, null, 2));
  };

  saveOpinions = function() {
    return fs.writeFileSync("opinions.json", JSON.stringify(opinions, null, 2));
  };

  saveCompanies = function() {
    return fs.writeFileSync("companies.json", JSON.stringify(companies, null, 2));
  };

  saveNicknames = function() {
    return fs.writeFileSync("nicknames.json", JSON.stringify(nicknames, null, 2));
  };

  saveIgnored = function() {
    return fs.writeFileSync("ignored.json", JSON.stringify(ignored, null, 2));
  };

  saveDiscordAuth = function() {
    return fs.writeFileSync("auth.json", JSON.stringify(discordAuth, null, 2));
  };

  saveUserPlaylists = function() {
    return fs.writeFileSync("userplaylists.json", JSON.stringify(userPlaylists, null, 2));
  };

  logOutput = function(msg) {
    output.push(msg);
    while (output.length > 10) {
      output.shift();
    }
  };

  filterObject = function(inputObject, propList) {
    var len, m, outputObject, prop;
    outputObject = {};
    for (m = 0, len = propList.length; m < len; m++) {
      prop = propList[m];
      outputObject[prop] = inputObject[prop];
    }
    return outputObject;
  };

  logPlay = function(msg) {
    var logUserTag;
    logUserTag = "Anonymous";
    if ((msg.token != null) && (discordAuth[msg.token] != null)) {
      logUserTag = discordAuth[msg.token].tag;
    }
    return logger.play('play', {
      src: msg.cmd,
      sid: msg.id,
      tag: logUserTag,
      t: now(),
      video: filterObject(msg.info.current, ['added', 'artist', 'duration', 'id', 'nickname', 'title'])
    });
  };

  refreshDashboards = function() {
    var results, sid, soc;
    results = [];
    for (sid in sockets) {
      soc = sockets[sid];
      results.push(soc.emit('refresh', {}));
    }
    return results;
  };

  requestDashboardRefresh = function() {
    return dashboardsRefreshNeeded = true;
  };

  refreshDashboardsIfNeeded = function() {
    if (dashboardsRefreshNeeded) {
      // console.log "refreshDashboardsIfNeeded(): refreshing..."
      dashboardsRefreshNeeded = false;
      return refreshDashboards();
    }
  };

  soloBroadcast = function(sender, msg) {
    var sid, soc;
    for (sid in sockets) {
      soc = sockets[sid];
      if (sid === sender) {
        continue;
      }
      if (soloSessions[sid] === msg.id) {
        soc.emit('solo', msg);
      }
    }
  };

  saveState = function() {
    var e, len, len1, m, q, savedHistory, savedQueue, state;
    savedQueue = [];
    for (m = 0, len = queue.length; m < len; m++) {
      e = queue[m];
      savedQueue.push(e.id);
    }
    savedHistory = [];
    for (q = 0, len1 = history.length; q < len1; q++) {
      e = history[q];
      savedHistory.push(e.id);
    }
    state = {
      history: savedHistory,
      queue: savedQueue
    };
    fs.writeFileSync("state.json", JSON.stringify(state, null, 2));
    return console.log(`Saved State: (${savedQueue.length} in queue, ${savedHistory.length} in history)`);
  };

  calcOther = function() {
    var count, n, names, other, props, sid, soc, user;
    names = [];
    count = 0;
    for (sid in sockets) {
      soc = sockets[sid];
      if (isPlaying[sid]) {
        count += 1;
      }
      if ((playingName[sid] != null) && playingName[sid].length > 0) {
        props = [];
        n = getNickname(playingName[sid]);
        user = getUserFromNickname(n);
        if (nicknames[user] != null) {
          if (ignored[getNickname(user)]) {
            props.push("Ignored");
          } else {
            props.push("Auto");
          }
        }
        if (sfwOnly[sid]) {
          props.push("SFW");
        }
        if (props.length > 0) {
          n += ` (${props.join(", ")})`;
        }
        names.push(n);
      }
    }
    names.sort();
    other = {
      playing: count,
      names: names,
      solo: Object.keys(soloSessions).length,
      current: {
        id: lastPlayed.id,
        artist: lastPlayed.artist,
        title: lastPlayed.title
      }
    };
    return other;
  };

  logAutoskip = function() {
    var l;
    if (autoskipCount > 0) {
      l = autoskipList.join(", ");
      if (autoskipCount > AUTOSKIPLIST_COUNT) {
        l += `, +${autoskipCount - AUTOSKIPLIST_COUNT} more`;
      }
    }
    // logOutput("MTV: Auto-skipped #{autoskipCount} song#{if autoskipCount == 1 then "" else "s"}: `#{l}`")
    autoskipCount = 0;
    autoskipList = [];
  };

  shouldSkip = function(e) {
    var feeling, hasOpinionCount, ref, sid, soc, user, weakOpinionCount;
    // console.log "shouldSkip: e #{JSON.stringify(e)}"
    if (e.tags.nsfw) {
// console.log "shouldSkip: sfwOnly #{JSON.stringify(sfwOnly)}"
      for (sid in sockets) {
        soc = sockets[sid];
        if (!isPlaying[sid]) {
          continue;
        }
        if (sfwOnly[sid]) {
          console.log(`autoskip: ${playingName[sid]} can't watch NSFW content, bailing out.`);
          return true;
        }
      }
    }
    hasOpinionCount = 0;
    weakOpinionCount = 0;
    for (sid in sockets) {
      soc = sockets[sid];
      if (!isPlaying[sid]) {
        continue;
      }
      if (playingName[sid] != null) {
        if (nicknames[playingName[sid]] != null) {
          // This playingName has a nickname, it must be the user
          user = playingName[sid];
        } else {
          user = getUserFromNickname(playingName[sid]);
          if (user === playingName[sid]) {
            // The nickname provided doesn't map to ID we know, skip them
            continue;
          }
        }
        if (ignored[getNickname(playingName[sid])]) {
          // This nickname is explicitly ignored for now
          continue;
        }
        feeling = (ref = opinions[e.id]) != null ? ref[user] : void 0;
        if ((feeling != null) && (constants.badOpinions[feeling] != null)) {
          console.log(`autoskip: ${user} ${feeling}s this song, skipping.`);
          return true;
        }
        hasOpinionCount += 1;
        if (feeling == null) {
          // console.log "autoskip: #{user} has no opinion of this song, bailing out."
          continue;
        }
        if (constants.weakOpinions[feeling] != null) {
          weakOpinionCount += 1;
        }
        if (constants.goodOpinions[feeling] != null) {
          // console.log "autoskip: #{user} #{feeling}s this song, bailing out."
          continue; // return false
        }
      }
    }
    if ((hasOpinionCount > 0) && (hasOpinionCount === weakOpinionCount)) {
      console.log(`autoskip: Everyone (${weakOpinionCount}) has a weak opinion, skipping.`);
      return true;
    }
    return false;
  };

  autoskip = function() {
    var artist, border, feeling, feelings, len, len1, len2, licensingInfo, line, list, logText, m, maxLineLength, o, q, r, ref, ref1, strs, title;
    if (lastPlayed === null) {
      console.log("autoskip: lastPlayed is null.");
      return;
    }
    if (shouldSkip(lastPlayed)) {
      strs = calcEntryStrings(lastPlayed);
      console.log(`autoskip: Autoskipped ${strs.description}`);
      if (autoskipTimeout != null) {
        clearTimeout(autoskipTimeout);
        autoskipTimeout = null;
      }
      autoskipTimeout = setTimeout(logAutoskip, 1000);
      autoskipCount += 1;
      if (autoskipCount <= AUTOSKIPLIST_COUNT) {
        autoskipList.push(`${strs.artist} - ${strs.title}`);
      }
      playNext();
      return;
    }
    console.log("autoskip: Nothing to do.");
    if (echoEnabled && echoNewSong) {
      echoNewSong = false;
      licensingInfo = calcLicensingInfo(lastPlayed);
      artist = licensingInfo.artist;
      artist = artist.replace(/^\s+/, "");
      artist = artist.replace(/\s+$/, "");
      title = licensingInfo.title;
      title = title.replace(/^\s+/, "");
      title = title.replace(/\s+$/, "");
      logText = `${artist}\n\"${title}\"\n${licensingInfo.company}`;
      feelings = [];
      ref = constants.opinionOrder;
      for (m = 0, len = ref.length; m < len; m++) {
        o = ref[m];
        if (licensingInfo.opinions[o] != null) {
          feelings.push(o);
        }
      }
      if (feelings.length === 0) {
        logText += "\nNo Opinions";
      } else {
        for (q = 0, len1 = feelings.length; q < len1; q++) {
          feeling = feelings[q];
          list = licensingInfo.opinions[feeling];
          list.sort();
          logText += `\n${feeling.charAt(0).toUpperCase() + feeling.slice(1)}: ${list.join(', ')}`;
        }
      }
      maxLineLength = 0;
      ref1 = logText.split(/\n/);
      for (r = 0, len2 = ref1.length; r < len2; r++) {
        line = ref1[r];
        if (maxLineLength < line.length) {
          maxLineLength = line.length;
        }
      }
      border = "--------------------------------------------------------------".substr(0, maxLineLength);
      logText = `\`\`\`\n${border}\n${logText}\n${border}\`\`\``;
      logOutput(logText);
    }
  };

  // logOutput("MTV: Playing: #{strs.description}")
  checkAutoskip = function() {
    return setTimeout(function() {
      return autoskip();
    }, 0);
  };

  songEnding = function() {
    var pkt, results, socket, socketId, strs;
    if (lastPlayed == null) {
      return;
    }
    strs = calcEntryStrings(lastPlayed);
    results = [];
    for (socketId in sockets) {
      socket = sockets[socketId];
      pkt = calcLicensingInfo(lastPlayed);
      results.push(socket.emit('ending', pkt));
    }
    return results;
  };

  someoneIsWatchingWithAutoskip = function() {
    var sid, soc, someoneWatching;
    someoneWatching = false;
    for (sid in sockets) {
      soc = sockets[sid];
      if (isPlaying[sid] && playingName[sid] && !ignored[getNickname(playingName[sid])]) {
        someoneWatching = true;
        break;
      }
    }
    return someoneWatching;
  };

  checkIfEveryoneLeft = function() {
    if (nobodyWatchingTimeout != null) {
      return;
    }
    if (!someoneIsWatchingWithAutoskip()) {
      return nobodyWatchingTimeout = setTimeout(function() {
        if (echoEnabled) {
          echoEnabled = false;
          logOutput("MTV: Auto-disabling echo (all autoskippers left)");
        }
        return nobodyWatchingTimeout = null;
      }, 15000);
    }
  };

  autoPlayNext = function() {
    var e;
    e = playNext();
    return console.log(`autoPlayNext: ${JSON.stringify(e, null, 2)}`);
  };

  play = function(e) {
    var endTime, pkt, socket, socketId, startTime;
    lastPlayedTime = now();
    lastPlayed = e;
    history.unshift(e);
    while (history.length > 20) {
      history.pop();
    }
    if (!shouldSkip(lastPlayed)) {
      console.log(e);
      pkt = calcLicensingInfo(e);
      pkt.id = e.id;
      pkt.start = e.start;
      pkt.end = e.end;
      for (socketId in sockets) {
        socket = sockets[socketId];
        socket.emit('play', pkt);
      }
      saveState();
      savePlaylist();
    }
    console.log(`Playing: ${e.title} [${e.id}]`);
    startTime = e.start;
    if (startTime < 0) {
      startTime = 0;
    }
    endTime = e.end;
    if (endTime < 0) {
      endTime = e.duration;
    }
    lastPlayedDuration = endTime - startTime;
    if (lastPlayedDuration > e.duration) {
      lastPlayedDuration = e.duration - startTime;
    }
    // sanity check?
    if (lastPlayedDuration < 20) {
      lastPlayedDuration = e.duration;
    }
    if (lastPlayedTimeout != null) {
      clearTimeout(lastPlayedTimeout);
      lastPlayedTimeout = null;
    }
    lastPlayedTimeout = setTimeout(autoPlayNext, (lastPlayedDuration + 3) * 1000);
    if (songEndingTimeout != null) {
      clearTimeout(songEndingTimeout);
      songEndingTimeout = null;
    }
    if (lastPlayedDuration > 30) {
      songEndingTimeout = setTimeout(songEnding, (lastPlayedDuration - 15) * 1000);
    }
    console.log(`Play: [${e.title}] [${lastPlayedDuration} seconds]`);
    echoNewSong = true;
    checkAutoskip();
  };

  parseDuration = function(s) {
    return iso8601.toSeconds(iso8601.parse(s));
  };

  queueYoutubeTrending = function() {
    return new Promise(function(resolve, reject) {
      var req, url;
      url = `https://youtube.googleapis.com/youtube/v3/videos?part=snippet%2CcontentDetails%2Cstatistics&chart=mostPopular&maxResults=50&regionCode=US&videoCategoryId=10&key=${secrets.youtube}`;
      req = https.request(url, function(res) {
        var rawJSON;
        rawJSON = "";
        res.on('data', function(chunk) {
          return rawJSON += chunk;
        });
        res.on('error', function() {
          console.log("Error getting trending music");
          return resolve();
        });
        return res.on('end', function() {
          var chosenThumb, data, e, i, index, item, j, len, len1, len2, m, q, r, ref, ref1, saved, thumb, thumbType, thumbUrl, trendingQueue, unshuffledTrendingQueue;
          data = null;
          try {
            data = JSON.parse(rawJSON);
          } catch (error) {
            console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
            return;
          }
          saved = false;
          if ((data.items != null) && (data.items.length > 0)) {
            unshuffledTrendingQueue = [];
            ref = data.items;
            for (m = 0, len = ref.length; m < len; m++) {
              item = ref[m];
              chosenThumb = null;
              ref1 = item.snippet.thumbnails;
              for (thumbType in ref1) {
                thumb = ref1[thumbType];
                if (chosenThumb == null) {
                  chosenThumb = thumb;
                  continue;
                }
                if (thumbType === 'medium') {
                  chosenThumb = thumb;
                  break;
                }
                if (chosenThumb.height < thumb.height) {
                  chosenThumb = thumb;
                }
              }
              thumbUrl = null;
              if (chosenThumb != null) {
                thumbUrl = chosenThumb.url;
              }
              if (thumbUrl == null) {
                thumbUrl = '/unknown.png';
              }
              e = entryFromArg(item.id);
              if (playlist[e.id] != null) {
                unshuffledTrendingQueue.push(playlist[e.id]);
                e = playlist[e.id];
              } else {
                e.title = item.snippet.title;
                e.thumb = thumbUrl;
                e.user = YOUTUBE_USER;
                e.duration = parseDuration(item.contentDetails.duration);
                splitArtist(e, false);
                unshuffledTrendingQueue.push(e);
              }
              console.log(`Found trending title [${e.id}]: ${e.title}`);
            }
            // savePlaylist()
            // saved = true
            trendingQueue = [unshuffledTrendingQueue.shift()];
            for (index = q = 0, len1 = unshuffledTrendingQueue.length; q < len1; index = ++q) {
              i = unshuffledTrendingQueue[index];
              j = Math.floor(Math.random() * (index + 1));
              trendingQueue.push(trendingQueue[j]);
              trendingQueue[j] = i;
            }
            for (r = 0, len2 = trendingQueue.length; r < len2; r++) {
              e = trendingQueue[r];
              queue.unshift(e);
            }
          }
          return resolve();
        });
      });
      return req.end();
    });
  };

  queueYoutubePlaylist = function(playlistId) {
    return new Promise(function(resolve, reject) {
      var outerReq, url;
      url = `https://youtube.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${encodeURIComponent(playlistId)}&key=${secrets.youtube}`;
      outerReq = https.request(url, function(outerRes) {
        var rawJSON;
        rawJSON = "";
        outerRes.on('data', function(chunk) {
          return rawJSON += chunk;
        });
        outerRes.on('error', function() {
          console.log("Error getting playlist music");
          return resolve();
        });
        return outerRes.on('end', function() {
          var idList, idString, item, len, m, outerData, ref, req, unshuffledPlaylistQueue;
          outerData = null;
          try {
            outerData = JSON.parse(rawJSON);
          } catch (error) {
            console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
            resolve(0);
            return;
          }
          idList = [];
          if ((outerData.items != null) && (outerData.items.length > 0)) {
            unshuffledPlaylistQueue = [];
            ref = outerData.items;
            for (m = 0, len = ref.length; m < len; m++) {
              item = ref[m];
              if (item.snippet.resourceId.kind === 'youtube#video') {
                idList.push(item.snippet.resourceId.videoId);
              }
            }
          }
          if (idList.length === 0) {
            console.log(`ERROR: idList is empty: ${rawJSON}`);
            resolve(0);
            return;
          }
          idString = idList.join(',');
          console.log(`idString: ${idString}`);
          url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&key=${secrets.youtube}&id=${idString}`;
          req = https.request(url, function(res) {
            rawJSON = "";
            res.on('data', function(chunk) {
              return rawJSON += chunk;
            });
            res.on('error', function() {
              console.log("Error getting playlist music");
              return resolve(0);
            });
            return res.on('end', function() {
              var chosenThumb, data, e, i, index, j, len1, len2, len3, playlistCount, playlistQueue, q, r, ref1, ref2, saved, thumb, thumbType, thumbUrl, w;
              data = null;
              try {
                data = JSON.parse(rawJSON);
              } catch (error) {
                console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
                resolve(0);
                return;
              }
              saved = false;
              playlistCount = 0;
              if ((data.items != null) && (data.items.length > 0)) {
                unshuffledPlaylistQueue = [];
                ref1 = data.items;
                for (q = 0, len1 = ref1.length; q < len1; q++) {
                  item = ref1[q];
                  chosenThumb = null;
                  ref2 = item.snippet.thumbnails;
                  for (thumbType in ref2) {
                    thumb = ref2[thumbType];
                    if (chosenThumb == null) {
                      chosenThumb = thumb;
                      continue;
                    }
                    if (thumbType === 'medium') {
                      chosenThumb = thumb;
                      break;
                    }
                    if (chosenThumb.height < thumb.height) {
                      chosenThumb = thumb;
                    }
                  }
                  thumbUrl = null;
                  if (chosenThumb != null) {
                    thumbUrl = chosenThumb.url;
                  }
                  if (thumbUrl == null) {
                    thumbUrl = '/unknown.png';
                  }
                  e = entryFromArg(item.id);
                  if (playlist[e.id] != null) {
                    unshuffledPlaylistQueue.push(playlist[e.id]);
                    e = playlist[e.id];
                  } else {
                    e.title = item.snippet.title;
                    e.thumb = thumbUrl;
                    e.user = YOUTUBE_USER;
                    e.duration = parseDuration(item.contentDetails.duration);
                    splitArtist(e, false);
                    unshuffledPlaylistQueue.push(e);
                  }
                  console.log(`Found playlist video title [${e.id}]: ${e.title}`);
                }
                // savePlaylist()
                // saved = true
                playlistQueue = [unshuffledPlaylistQueue.shift()];
                for (index = r = 0, len2 = unshuffledPlaylistQueue.length; r < len2; index = ++r) {
                  i = unshuffledPlaylistQueue[index];
                  j = Math.floor(Math.random() * (index + 1));
                  playlistQueue.push(playlistQueue[j]);
                  playlistQueue[j] = i;
                }
                for (w = 0, len3 = playlistQueue.length; w < len3; w++) {
                  e = playlistQueue[w];
                  queue.unshift(e);
                }
                playlistCount = playlistQueue.length;
              }
              return resolve(playlistCount);
            });
          });
          return req.end();
        });
      });
      return outerReq.end();
    });
  };

  convertYoutubePlaylist = function(output, playlistId, pageToken = null) {
    return new Promise(function(resolve, reject) {
      var outerReq, url;
      url = `https://youtube.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${encodeURIComponent(playlistId)}&key=${secrets.youtube}`;
      if (pageToken != null) {
        url += `&pageToken=${pageToken}`;
      }
      outerReq = https.request(url, function(outerRes) {
        var rawJSON;
        rawJSON = "";
        outerRes.on('data', function(chunk) {
          return rawJSON += chunk;
        });
        outerRes.on('error', function() {
          console.log("Error getting playlist music");
          return resolve(output);
        });
        return outerRes.on('end', async function() {
          var item, len, m, outerData, ref, unshuffledPlaylistQueue;
          outerData = null;
          try {
            outerData = JSON.parse(rawJSON);
          } catch (error) {
            console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
            resolve(output);
            return;
          }
          if ((outerData.items != null) && (outerData.items.length > 0)) {
            unshuffledPlaylistQueue = [];
            ref = outerData.items;
            for (m = 0, len = ref.length; m < len; m++) {
              item = ref[m];
              if (item.snippet.resourceId.kind === 'youtube#video') {
                output.push(item.snippet.resourceId.videoId);
              }
            }
          }
          if (outerData.nextPageToken != null) {
            return resolve((await convertYoutubePlaylist(output, playlistId, outerData.nextPageToken)));
          } else {
            return resolve(output);
          }
        });
      });
      return outerReq.end();
    });
  };

  getYoutubeData = function(e) {
    return limiter.schedule(function() {
      e.id = e.id.replace(/\?.+$/, "");
      console.log(`Looking up: ${e.id}`);
      return new Promise(function(resolve, reject) {
        var idInfo, req, url;
        idInfo = filters.calcIdInfo(e.id);
        if ((idInfo == null) || (idInfo.provider !== 'youtube')) {
          resolve(false);
          return;
        }
        url = `https://www.googleapis.com/youtube/v3/videos?part=snippet,contentDetails&key=${secrets.youtube}&id=${encodeURIComponent(idInfo.real)}`;
        req = https.request(url, function(res) {
          var rawJSON;
          rawJSON = "";
          res.on('data', function(chunk) {
            return rawJSON += chunk;
          });
          res.on('error', function() {
            console.log(`Error [${idInfo.real}]`);
            return resolve(false);
          });
          return res.on('end', function() {
            var chosenThumb, data, ref, saved, thumb, thumbType, thumbUrl;
            data = null;
            try {
              data = JSON.parse(rawJSON);
            } catch (error) {
              console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
              return;
            }
            console.log(`looking up ${idInfo.real}`);
            saved = false;
            if ((data.items != null) && (data.items.length > 0)) {
              // console.log JSON.stringify(data, null, 2)
              if ((data.items[0].snippet != null) && (data.items[0].snippet.title != null) && (data.items[0].snippet.thumbnails != null) && (data.items[0].contentDetails.duration != null)) {
                chosenThumb = null;
                ref = data.items[0].snippet.thumbnails;
                for (thumbType in ref) {
                  thumb = ref[thumbType];
                  if (chosenThumb == null) {
                    chosenThumb = thumb;
                    continue;
                  }
                  if (thumbType === 'medium') {
                    chosenThumb = thumb;
                    break;
                  }
                  if (chosenThumb.height < thumb.height) {
                    chosenThumb = thumb;
                  }
                }
                thumbUrl = null;
                if (chosenThumb != null) {
                  thumbUrl = chosenThumb.url;
                }
                if (thumbUrl == null) {
                  thumbUrl = '/unknown.png';
                }
                e.title = data.items[0].snippet.title;
                e.thumb = thumbUrl;
                e.duration = parseDuration(data.items[0].contentDetails.duration);
                splitArtist(e);
                console.log(`Found title [${idInfo.real}]: '${e.artist}' - '${e.title}'`);
                savePlaylist();
                saved = true;
              }
            }
            if (!saved) {
              console.log(`Nope [${idInfo.real}]`);
              if (playlist[e.id] != null) {
                delete playlist[e.id];
              }
              queue = queue.filter(function(a) {
                return a.id !== e.id;
              });
              history = history.filter(function(a) {
                return a.id !== e.id;
              });
              savePlaylist();
              saveState();
              logOutput(`MTV: Auto-removed: \`${e.id}\` (invalid YouTube ID)`);
            }
            return resolve(saved);
          });
        });
        return req.end();
      });
    });
  };

  playNext = function() {
    var e, i, index, j, k, len, m, unshuffled, v;
    if (queue.length < 1) {
      unshuffled = [];
      for (k in playlist) {
        v = playlist[k];
        unshuffled.push(v);
      }
      if (unshuffled.length > 0) {
        queue = [unshuffled.shift()];
        for (index = m = 0, len = unshuffled.length; m < len; index = ++m) {
          i = unshuffled[index];
          j = Math.floor(Math.random() * (index + 1));
          queue.push(queue[j]);
          queue[j] = i;
        }
      }
    }
    if (queue.length < 1) {
      console.log("Nothing to play!");
      return null;
    }
    e = queue.shift();
    console.log(e);
    play(e);
    return e;
  };

  // parses strings like 1h30m20s to seconds
  getLetterTime = function(timeString) {
    var i, m, ref, timePairs, timeValues, totalSeconds;
    totalSeconds = 0;
    timeValues = {
      's': 1,
      'm': 1 * 60,
      'h': 1 * 60 * 60,
      'd': 1 * 60 * 60 * 24,
      'w': 1 * 60 * 60 * 24 * 7
    };
    // expand to "1 h 30 m 20 s" and split
    timeString = timeString.replace(/([smhdw])/g, ' $1 ').trim();
    timePairs = timeString.split(' ');
    for (i = m = 0, ref = timePairs.length; m < ref; i = m += 2) {
      totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs[i + 1] || 's'];
    }
    return totalSeconds;
  };

  // parses strings like 1:30:20 to seconds
  getColonTime = function(timeString) {
    var i, m, ref, timePairs, timeValues, totalSeconds;
    totalSeconds = 0;
    timeValues = [1, 1 * 60, 1 * 60 * 60, 1 * 60 * 60 * 24, 1 * 60 * 60 * 24 * 7];
    timePairs = timeString.split(':');
    for (i = m = 0, ref = timePairs.length; (0 <= ref ? m < ref : m > ref); i = 0 <= ref ? ++m : --m) {
      totalSeconds += parseInt(timePairs[i], 10) * timeValues[timePairs.length - i - 1];
    }
    return totalSeconds;
  };

  getTime = function(timeString) {
    if (timeString == null) {
      return 0;
    }
    if (timeString.match(/^(\d+[smhdw]?)+$/)) {
      return getLetterTime(timeString);
    }
    if (timeString.match(/^(\d+:?)+$/)) {
      return getColonTime(timeString);
    }
    return 0;
  };

  entryFromArg = function(arg) {
    var endTime, id, idInfo, startTime, t, url, v;
    if (arg == null) {
      return null;
    }
    arg = String(arg);
    id = null;
    startTime = -1;
    endTime = -1;
    try {
      url = new URL(arg);
    } catch (error) {
      url = null;
      id = arg;
    }
    if ((id == null) && (url.hostname === 'youtu.be')) {
      id = url.pathname.replace(/^\//, "");
      id = `youtube_${id}`;
    }
    if ((id == null) && url.hostname.match(/youtube.com$/)) {
      v = url.searchParams.get('v');
      if (v != null) {
        id = `youtube_${v}`;
      }
    }
    idInfo = filters.calcIdInfo(id);
    if (idInfo == null) {
      // backwards compatibility
      id = `youtube_${id}`;
      idInfo = filters.calcIdInfo(id);
    }
    if (url != null) {
      t = url.searchParams.get('t');
      if (t != null) {
        startTime = getTime(t);
      }
      t = url.searchParams.get('start');
      if (t != null) {
        startTime = getTime(t);
      }
      t = url.searchParams.get('end');
      if (t != null) {
        endTime = getTime(t);
      }
    }
    if (id == null) {
      return null;
    }
    if (id.match(/\?/)) {
      return null;
    }
    return {
      id: id,
      start: startTime,
      end: endTime,
      added: now(),
      tags: {}
    };
  };

  playlistIDFromArg = function(arg) {
    var id, list, url;
    if (arg == null) {
      return null;
    }
    arg = String(arg);
    id = null;
    if (!arg.match("^https?:")) {
      return arg;
    }
    try {
      url = new URL(arg);
    } catch (error) {
      url = null;
      id = arg;
    }
    if ((id == null) && (url.hostname === 'youtu.be') || url.hostname.match(/youtube.com$/)) {
      list = url.searchParams.get('list');
      if (list != null) {
        id = list;
      }
    }
    if (id == null) {
      return null;
    }
    if (id.match(/\?/)) {
      return null;
    }
    if (id.match(/\//)) {
      return null;
    }
    return id;
  };

  prettyDuration = function(duration) {
    var hours, minutes, str;
    str = "";
    hours = Math.floor(duration / 3600);
    if (hours > 0) {
      duration -= hours * 3600;
      str += `${hours}h`;
    }
    minutes = Math.floor(duration / 60);
    if (minutes > 0) {
      duration -= minutes * 60;
      str += `${minutes}m`;
    }
    if ((duration > 0) || (str.length === 0)) {
      str += `${duration}s`;
    }
    return str;
  };

  calcEntryStrings = function(e) {
    var actualDuration, artist, count, endTime, feeling, idInfo, nick, opinionString, opinionTable, ownerNick, params, ref, ref1, startTime, tagsString, title, url, user, userFeeling, whoList;
    idInfo = filters.calcIdInfo(e.id);
    if (idInfo == null) {
      console.log("calcEntryStrings: bad idInfo: ", e);
      return {};
    }
    url = idInfo.url;
    if (idInfo.provider === 'youtube') {
      params = "";
      if (e.start >= 0) {
        params += params.length === 0 ? "?" : "&";
        params += `start=${e.start}`;
      }
      if (e.end >= 0) {
        params += params.length === 0 ? "?" : "&";
        params += `end=${e.end}`;
      }
      url = `${url}${params}`;
    }
    if (e.title != null) {
      title = `${e.title} `;
    } else {
      title = " ";
    }
    if (e.artist != null) {
      artist = e.artist;
    } else {
      artist = "Unknown";
    }
    startTime = e.start;
    if (startTime < 0) {
      startTime = 0;
    }
    endTime = e.end;
    if (endTime < 0) {
      endTime = e.duration;
    }
    actualDuration = endTime - startTime;
    opinionTable = {};
    opinionString = "";
    ref = e.opinions;
    for (feeling in ref) {
      count = ref[feeling];
      if (opinionTable[feeling] == null) {
        opinionTable[feeling] = [];
      }
      opinionString += `, ${count} ${feeling}${count === 1 ? "" : "s"}`;
      if ((opinions[e.id] != null) && (count > 0)) {
        whoList = [];
        ref1 = opinions[e.id];
        for (user in ref1) {
          userFeeling = ref1[user];
          if (feeling === userFeeling) {
            nick = getNickname(user);
            whoList.push(nick);
            opinionTable[feeling].push(nick);
          }
        }
        whoList.sort();
        opinionString += ` (${whoList.join(', ')})`;
      }
    }
    tagsString = Object.keys(e.tags).sort().join(', ');
    if (tagsString.length > 0) {
      tagsString = ` - [${tagsString}]`;
    }
    ownerNick = getNickname(e.user);
    return {
      artist: artist,
      title: title,
      opinions: opinionTable,
      url: url,
      description: `**${artist}** - **${title}** \`[${ownerNick}, ${prettyDuration(actualDuration)}${opinionString}]${tagsString}\``
    };
  };

  calcLicensingInfo = function(e) {
    var company, nickname, strs;
    strs = calcEntryStrings(e);
    if (companies[e.user] != null) {
      company = companies[e.user];
    } else {
      nickname = getNickname(e.user);
      company = nickname.charAt(0).toUpperCase() + nickname.slice(1);
      company += " Records";
    }
    return {
      user: e.user,
      artist: strs.artist,
      title: strs.title,
      opinions: strs.opinions,
      company: company,
      thumb: e.thumb
    };
  };

  updateNickname = function(e) {
    e.nickname = getNickname(e.user);
  };

  updateNicknames = function(entries, isMap) {
    var e, k, len, m, v;
    if (isMap) {
      for (k in entries) {
        v = entries[k];
        updateNickname(v);
      }
    } else {
      for (m = 0, len = entries.length; m < len; m++) {
        e = entries[m];
        updateNickname(e);
      }
    }
  };

  updateOpinion = function(e) {
    var feeling, o, ref, user;
    o = {};
    if (opinions[e.id] != null) {
      ref = opinions[e.id];
      for (user in ref) {
        feeling = ref[user];
        if (o[feeling] == null) {
          o[feeling] = 0;
        }
        o[feeling] += 1;
      }
    }
    e.opinions = o;
  };

  updateOpinions = function(entries, isMap) {
    var e, k, len, m, v;
    if (isMap) {
      for (k in entries) {
        v = entries[k];
        updateOpinion(v);
      }
    } else {
      for (m = 0, len = entries.length; m < len; m++) {
        e = entries[m];
        updateOpinion(e);
      }
    }
  };

  calcUserInfo = function(user) {
    var base, base1, base2, base3, e, feeling, incoming, k, nickname, otherUser, outgoing, ref, userInfo;
    userInfo = {
      added: [],
      opinions: {},
      otherOpinions: {
        incoming: {},
        outgoing: {}
      },
      otherTotals: {
        incoming: {},
        outgoing: {}
      }
    };
    incoming = userInfo.otherOpinions.incoming;
    outgoing = userInfo.otherOpinions.outgoing;
    user = getUserFromNickname(user);
    for (k in playlist) {
      e = playlist[k];
      if (e.user === user) {
        userInfo.added.push(e);
        if (opinions[e.id] != null) {
          ref = opinions[e.id];
          for (otherUser in ref) {
            feeling = ref[otherUser];
            otherUser = getNickname(otherUser);
            if (incoming[otherUser] == null) {
              incoming[otherUser] = {};
            }
            if ((base = incoming[otherUser])[feeling] == null) {
              base[feeling] = 0;
            }
            incoming[otherUser][feeling] += 1;
            if ((base1 = userInfo.otherTotals.incoming)[feeling] == null) {
              base1[feeling] = 0;
            }
            userInfo.otherTotals.incoming[feeling] += 1;
          }
        }
      }
      if (opinions[e.id] != null) {
        if (opinions[e.id][user] != null) {
          feeling = opinions[e.id][user];
          if (userInfo.opinions[feeling] == null) {
            userInfo.opinions[feeling] = [];
          }
          userInfo.opinions[feeling].push(e);
          nickname = getNickname(e.user);
          if (outgoing[nickname] == null) {
            outgoing[nickname] = {};
          }
          if ((base2 = outgoing[nickname])[feeling] == null) {
            base2[feeling] = 0;
          }
          outgoing[nickname][feeling] += 1;
          if ((base3 = userInfo.otherTotals.outgoing)[feeling] == null) {
            base3[feeling] = 0;
          }
          userInfo.otherTotals.outgoing[feeling] += 1;
        }
      }
    }
    return userInfo;
  };

  calcUserOpinions = function(user) {
    var e, k, userOpinions;
    user = getUserFromNickname(user);
    userOpinions = {};
    for (k in playlist) {
      e = playlist[k];
      if ((opinions[e.id] != null) && (opinions[e.id][user] != null)) {
        userOpinions[e.id] = opinions[e.id][user];
      }
    }
    return userOpinions;
  };

  isOpinionCommand = function(cmd) {
    if (cmd === 'none') {
      return true;
    }
    return constants.opinions[cmd] != null;
  };

  run = async function(args, user) {
    var anonCount, cmd, companyArgs, concatenatedArgs, count, e, editArgs, extraSkips, i, i1, id, idInfo, ignoreArgs, ignoreCmd, ignoreName, index, j, j1, k, k1, knownTags, l1, legalTags, len, len1, len2, len3, len4, m, m1, n1, name, name1, nameString, newCompany, newNickname, newValue, nicknameArgs, oldValue, other, playArgs, playNewlines, playQueue, playSubstring, playlistCount, playlistID, prettyList, property, q, r, real, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, repeatCount, result, ret, saved, strs, tag, tagArgs, tagName, title, unsortedQueue, v, w, x, y, z;
    cmd = 'who';
    if (args.length > 0) {
      cmd = args[0];
      cmd = cmd.replace(/^ +/, "");
      cmd = cmd.replace(/ +$/, "");
      if (cmd.length === 0) {
        cmd = 'who';
      }
    }
    // Sanitize command
    cmd = cmd.replace(/[^a-zA-Z0-9]/g, "");
    if (isOpinionCommand(cmd)) {
      e = null;
      if (args.length > 1) {
        if (args[1].toLowerCase() === 'last') {
          if (history.length < 2) {
            return "MTV [opinion]: Can't updated last song; no history.";
          }
          e = history[1];
        } else {
          e = entryFromArg(args[1]);
          if (e == null) {
            return `MTV [opinion]: I don't know what ${args[1]} is.`;
          }
        }
        if (playlist[e.id] == null) {
          return `MTV [opinion]: \`${e.id}\` is not in the pool.`;
        }
        e = playlist[e.id];
      }
      if (e == null) {
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        e = lastPlayed;
      }
      if (opinions[name1 = e.id] == null) {
        opinions[name1] = {};
      }
      if (cmd === 'none') {
        if (opinions[e.id][user] != null) {
          delete opinions[e.id][user];
        }
      } else {
        opinions[e.id][user] = cmd;
      }
      updateOpinion(e);
      strs = calcEntryStrings(e);
      saveOpinions();
      requestDashboardRefresh();
      checkAutoskip();
      return `MTV: Updated: ${strs.description}`;
    }
    switch (cmd) {
      case 'help':
      case 'commands':
        return `MTV: Help: ${secrets.url}/help/`;
      case 'here':
      case 'watching':
      case 'web':
      case 'website':
        other = calcOther();
        nameString = "";
        if (other.playing === 0) {
          return `MTV: [Here] Nobody is watching live. _(${other.solo} solo session${other.solo === 1 ? "" : "s"})_`;
        }
        anonCount = other.playing - other.names.length;
        if (other.names.length > 0) {
          nameString = "";
          ref = other.names;
          for (m = 0, len = ref.length; m < len; m++) {
            name = ref[m];
            if (nameString.length > 0) {
              nameString += ", ";
            }
            nameString += `\`${name}\``;
          }
        }
        if (anonCount > 0) {
          if (nameString.length > 0) {
            nameString += " + ";
          }
          nameString += `**${anonCount}** anonymous`;
        }
        return `MTV: [Here] Watching: ${nameString} _(${other.solo} solo session${other.solo === 1 ? "" : "s"})_`;
      case 'what':
      case 'whatisthis':
      case 'who':
      case 'whodis':
      case 'why':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        strs = calcEntryStrings(lastPlayed);
        return `MTV: Playing: ${strs.description}`;
      case 'link':
      case 'url':
      case 'where':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        strs = calcEntryStrings(lastPlayed);
        return `MTV: ${strs.url}`;
      case 'echo':
        echoEnabled = !echoEnabled;
        if (echoEnabled) {
          return "MTV: Now echoing in chat.";
        } else {
          return "MTV: Echo disabled.";
        }
        break;
      case 'nsfw':
      case 'sfw':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        if (cmd === 'nsfw') {
          lastPlayed.tags.nsfw = true;
        } else {
          if (lastPlayed.tags.nsfw != null) {
            delete lastPlayed.tags.nsfw;
          }
        }
        strs = calcEntryStrings(lastPlayed);
        savePlaylist();
        requestDashboardRefresh();
        checkAutoskip();
        return `MTV: (N)SFW Adjustment: ${strs.description}`;
      case 'host':
        if (args.length < 3) {
          return "MTV: Syntax: host [real] [url.mp4]";
        }
        real = args[1].replace(/[^a-zA-Z0-9_]/g, "");
        id = `mtv_${real}`;
        e = entryFromArg(id);
        if (playlist[e.id] != null) {
          strs = calcEntryStrings(playlist[e.id]);
          return `MTV: Already in pool: ${strs.description}`;
        }
        if (e == null) {
          return `MTV: host: invalid real: ${args[1]}`;
        }
        idInfo = filters.calcIdInfo(e.id);
        if ((idInfo == null) || (idInfo.provider !== 'mtv')) {
          return `MTV: host: invalid real: ${args[1]}`;
        }
        result = (await hosting.downloadVideo(real, args[2]));
        if (result.error) {
          return `MTV: host error: ${result.error}`;
        }
        e.user = user;
        e.artist = `Unset Artist ${real}`;
        e.title = `Unset Title ${real}`;
        e.thumb = result.thumb;
        e.duration = result.duration;
        playlist[e.id] = e;
        savePlaylist();
        return `MTV: Host[\`${e.id}\`] Successful (${e.duration}s duration). Please edit \`artist\` and \`title\` using \`#mtv edit ${e.id}\``;
      case 'add':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: add: invalid argument";
        }
        if (playlist[e.id] != null) {
          strs = calcEntryStrings(playlist[e.id]);
          return `MTV: Already in pool: ${strs.description}`;
        }
        e.user = user;
        playlist[e.id] = e;
        saved = (await getYoutubeData(e));
        if (saved) {
          savePlaylist();
          return `MTV: Add[\`${e.id}\`] Artist: \`${e.artist}\`, Title: \`${e.title}\``;
        } else {
          return `MTV: add ignoring invalid ID: \`${e.id}\``;
        }
        break;
      case 'adopt':
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        if (lastPlayed.user !== YOUTUBE_USER) {
          return `MTV: You may only adopt entries from ${YOUTUBE_USER}.`;
        }
        if (playlist[lastPlayed.id] != null) {
          strs = calcEntryStrings(playlist[lastPlayed.id]);
          return `MTV: Already in pool: ${strs.description}`;
        }
        lastPlayed.user = user;
        playlist[lastPlayed.id] = lastPlayed;
        savePlaylist();
        requestDashboardRefresh();
        return `MTV: Added to pool: \`${lastPlayed.id}\``;
      case 'ignore':
        ignoreCmd = args[1];
        ignoreArgs = [];
        for (i = q = 2, ref1 = args.length; (2 <= ref1 ? q < ref1 : q > ref1); i = 2 <= ref1 ? ++q : --q) {
          ignoreArgs.push(args[i]);
        }
        ignoreName = ignoreArgs.join(" ");
        switch (ignoreCmd) {
          case 'add':
            if (ignoreName.match(/^\s*$/)) {
              return "MTV: ignore add requires a nickname.";
            }
            if (ignored[ignoreName]) {
              return `MTV: \`${ignoreName}\` is already ignored.`;
            } else {
              ignored[ignoreName] = true;
              saveIgnored();
              return `MTV: Now ignoring nickname: \`${ignoreName}\``;
            }
            break;
          case 'remove':
            if (ignoreName.match(/^\s*$/)) {
              return "MTV: ignore remove requires a nickname.";
            }
            if (!ignored[ignoreName]) {
              return `MTV: \`${ignoreName}\` is already not ignored.`;
            } else {
              delete ignored[ignoreName];
              saveIgnored();
              checkAutoskip();
              return `MTV: No longer ignoring nickname: \`${ignoreName}\``;
            }
            break;
          case 'clear':
            ignored = {};
            saveIgnored();
            checkAutoskip();
            return "MTV: No longer ignoring anyone.";
          case 'list':
            prettyList = [];
            for (k in ignored) {
              v = ignored[k];
              prettyList.push(`\`${k}\``);
            }
            if (prettyList.length === 0) {
              return "MTV: Nobody is being ignored right now.";
            }
            return `MTV: Ignoring: ${prettyList.join(", ")}`;
          default:
            return "MTV: ignore [add/remove/clear/list]";
        }
        break;
      case 'edit':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: edit: invalid argument";
        }
        if (playlist[e.id] == null) {
          return "MTV: edit: Not in pool already, ignoring";
        }
        if (args.length < 3) {
          return "MTV: Syntax: edit [URL/id] [user/start/end/artist/title] [newValue]";
        }
        property = args[2].toLowerCase();
        editArgs = [];
        for (i = r = 3, ref2 = args.length; (3 <= ref2 ? r < ref2 : r > ref2); i = 3 <= ref2 ? ++r : --r) {
          editArgs.push(args[i]);
        }
        concatenatedArgs = editArgs.join(" ");
        switch (property) {
          case 'user':
            newValue = args[3];
            break;
          case 'start':
            newValue = parseInt(args[3]);
            if (isNaN(newValue)) {
              return `MTV: edit: invalid number ${args[3]}`;
            }
            if (newValue === 0) {
              newValue = -1;
            }
            break;
          case 'end':
            newValue = parseInt(args[3]);
            if (isNaN(newValue)) {
              return `MTV: edit: invalid number ${args[3]}`;
            }
            if (newValue >= playlist[e.id].duration) {
              newValue = -1;
            }
            break;
          case 'artist':
            newValue = concatenatedArgs;
            break;
          case 'title':
            newValue = concatenatedArgs;
            break;
          case 'tag':
          case 'untag':
            e = playlist[e.id];
            if (e == null) {
              return "MTV [edit]: Unknown id";
            }
            for (w = 0, len1 = editArgs.length; w < len1; w++) {
              tagName = editArgs[w];
              tagName = sanitizeTag(tagName);
              if (property === 'tag') {
                e.tags[tagName] = true;
              } else {
                if (e.tags[tagName] != null) {
                  delete e.tags[tagName];
                }
              }
            }
            strs = calcEntryStrings(e);
            savePlaylist();
            requestDashboardRefresh();
            checkAutoskip();
            return `MTV: Tags Updated: ${strs.description}`;
          default:
            return `MTV: edit: unknown property: ${property}`;
        }
        oldValue = playlist[e.id][property];
        playlist[e.id][property] = newValue;
        savePlaylist();
        requestDashboardRefresh();
        return `MTV: Edited: \`${e.id}\` [\`${property}\`] \`${oldValue}\` -> \`${newValue}\``;
      case 'tags':
        knownTags = {};
        for (k in playlist) {
          v = playlist[k];
          for (tag in v.tags) {
            knownTags[tag] = true;
          }
        }
        legalTags = Object.keys(knownTags).sort().join(", ");
        return `MTV [tags]: \`${legalTags}\``;
      case 'tag':
      case 'untag':
        if (args.length < 2) {
          return "MTV [tag]: Please provide a tag.";
        }
        if (lastPlayed === null) {
          return "MTV: I have no idea what's playing.";
        }
        tagArgs = [];
        for (i = x = 1, ref3 = args.length; (1 <= ref3 ? x < ref3 : x > ref3); i = 1 <= ref3 ? ++x : --x) {
          tagArgs.push(args[i]);
        }
        e = lastPlayed;
        for (y = 0, len2 = tagArgs.length; y < len2; y++) {
          tagName = tagArgs[y];
          tagName = sanitizeTag(tagName);
          if (cmd === 'tag') {
            e.tags[tagName] = true;
          } else {
            if (e.tags[tagName] != null) {
              delete e.tags[tagName];
            }
          }
        }
        strs = calcEntryStrings(e);
        savePlaylist();
        requestDashboardRefresh();
        checkAutoskip();
        return `MTV: Tags Updated: ${strs.description}`;
      case 'queue':
      case 'q':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: queue: invalid argument";
        }
        if (playlist[e.id] != null) {
          queue.unshift(playlist[e.id]);
          strs = calcEntryStrings(playlist[e.id]);
          ret = `MTV: Queued next (already in pool) ${strs.description}`;
        } else {
          e.user = user;
          playlist[e.id] = e;
          queue.unshift(playlist[e.id]);
          saved = (await getYoutubeData(e));
          if (saved) {
            savePlaylist();
            return `MTV: Queue[\`${e.id}\`] Artist: \`${e.artist}\`, Title: \`${e.title}\``;
          } else {
            ret = `MTV: queue ignoring invalid ID: \`${e.id}\``;
          }
        }
        saveState();
        requestDashboardRefresh();
        return ret;
      case 'block':
        if (args.length < 3) {
          return "MTV: Syntax: block [artist/title/tag] substring";
        }
        playArgs = [];
        for (i = z = 1, ref4 = args.length; (1 <= ref4 ? z < ref4 : z > ref4); i = 1 <= ref4 ? ++z : --z) {
          playArgs.push(args[i]);
        }
        playSubstring = playArgs.join(" ");
        playNewlines = playSubstring.replace(/\//g, "\n");
        filters.setServerDatabases(playlist, opinions, getUserFromNickname);
        unsortedQueue = (await filters.generateList(playNewlines));
        if (unsortedQueue == null) {
          return "MTV: Error getting block, sorry.";
        }
        if (unsortedQueue.length < 1) {
          return `MTV: No block matches for: \`${playSubstring}\``;
        }
        playQueue = [unsortedQueue.shift()];
        for (index = i1 = 0, len3 = unsortedQueue.length; i1 < len3; index = ++i1) {
          i = unsortedQueue[index];
          j = Math.floor(Math.random() * (index + 1));
          playQueue.push(playQueue[j]);
          playQueue[j] = i;
        }
        for (j1 = 0, len4 = playQueue.length; j1 < len4; j1++) {
          v = playQueue[j1];
          queue.unshift(v);
        }
        saveState();
        requestDashboardRefresh();
        return `MTV: Queued ${playQueue.length} unique video${playQueue.length === 1 ? "" : "s"} matching: \`${playSubstring}\``;
      case 'shuffle':
        queue = [];
        e = playNext();
        strs = calcEntryStrings(e);
        requestDashboardRefresh();
        return `MTV: Shuffled and playing a fresh song ${strs.description}`;
      case 'trending':
        await queueYoutubeTrending();
        e = playNext();
        strs = calcEntryStrings(e);
        requestDashboardRefresh();
        return `MTV: Queued up the top 50 trending music from youtube. First up: ${strs.description}`;
      case 'playlist':
        playlistID = playlistIDFromArg(args[1]);
        if (playlistID == null) {
          return `MTV: Unable to figure out playlistID from: \`${args[1]}\``;
        }
        playlistCount = (await queueYoutubePlaylist(playlistID));
        requestDashboardRefresh();
        if (playlistCount === 0) {
          return `MTV: Failed to find any videos with playlist ID \`${playlistID}\`.`;
        }
        return `MTV: Queued up ${playlistCount} videos from playlist ID \`${playlistID}\`.`;
      case 'company':
      case 'label':
        companyArgs = [];
        for (i = k1 = 1, ref5 = args.length; (1 <= ref5 ? k1 < ref5 : k1 > ref5); i = 1 <= ref5 ? ++k1 : --k1) {
          companyArgs.push(args[i]);
        }
        newCompany = companyArgs.join(" ");
        console.log(`newCompany: '${newCompany}'`);
        if (newCompany.match(/^\s*$/)) {
          if (companies[user] != null) {
            return `MTV: Your (\`${user}\`) current label is: \`${companies[user]}\``;
          } else {
            return `MTV: You (\`${user}\`) have not set a label yet.\``;
          }
        }
        companies[user] = newCompany;
        saveCompanies();
        return `MTV: \`${user}\`'s new label: \`${newCompany}\``;
      case 'nickname':
      case 'name':
        nicknameArgs = [];
        for (i = l1 = 1, ref6 = args.length; (1 <= ref6 ? l1 < ref6 : l1 > ref6); i = 1 <= ref6 ? ++l1 : --l1) {
          nicknameArgs.push(args[i]);
        }
        newNickname = nicknameArgs.join(" ");
        console.log(`newNickname: '${newNickname}'`);
        if (newNickname.match(/^\s*$/)) {
          if (nicknames[user] != null) {
            return `MTV: Your (\`${user}\`) current nickname is: \`${nicknames[user]}\``;
          } else {
            return `MTV: You (\`${user}\`) have not set a nickname yet.\``;
          }
        }
        nicknames[user] = newNickname;
        saveNicknames();
        requestDashboardRefresh();
        return `MTV: \`${user}\`'s new nickname: \`${newNickname}\``;
      case 'remove':
      case 'delete':
      case 'del':
        e = entryFromArg(args[1]);
        if (e == null) {
          return "MTV: remove: invalid argument";
        }
        if (playlist[e.id] != null) {
          delete playlist[e.id];
          savePlaylist();
          title = e.title;
          if (title == null) {
            title = e.id;
          }
          return `MTV: Deleted ${title} from shuffled pool.`;
        } else {
          return `MTV: \`${e.id}\` is already not in the shuffled pool.`;
        }
        break;
      case 'repeat':
        if (lastPlayed == null) {
          return "MTV: I have no idea what's playing.";
        }
        repeatCount = 1;
        if (args.length > 1) {
          repeatCount = parseInt(args[1]);
          if (repeatCount < 1) {
            repeatCount = 1;
          }
          if (repeatCount > 10) {
            repeatCount = 10;
          }
        }
        for (i = m1 = 0, ref7 = repeatCount; (0 <= ref7 ? m1 < ref7 : m1 > ref7); i = 0 <= ref7 ? ++m1 : --m1) {
          queue.unshift(lastPlayed);
        }
        saveState();
        requestDashboardRefresh();
        strs = calcEntryStrings(lastPlayed);
        return `MTV: Re-queued **${repeatCount}**x: ${strs.description}`;
      case 'next':
      case 'skip':
        extraSkips = 0;
        if (args.length > 1) {
          count = parseInt(args[1]);
          if (count > 1) {
            extraSkips = count - 1;
          }
        }
        if (lastPlayed != null) {
          strs = calcEntryStrings(lastPlayed);
          ret = `MTV: Skipped ${strs.description}`;
        }
        for (i = n1 = 0, ref8 = extraSkips; (0 <= ref8 ? n1 < ref8 : n1 > ref8); i = 0 <= ref8 ? ++n1 : --n1) {
          queue.shift();
        }
        e = playNext();
        if (ret == null) {
          ret = "MTV: Skipped unknown song";
        }
        return ret;
    }
    return `MTV: unknown command ${cmd}`;
  };

  processOAuth = function(code) {
    console.log(`processOAuth: ${code}`);
    return new Promise(function(resolve, reject) {
      var options, params, postdata, req;
      if ((code == null) || (code.length < 1)) {
        resolve('');
        return;
      }
      postdata = {
        client_id: secrets.discordClientID,
        client_secret: secrets.discordClientSecret,
        grant_type: 'authorization_code',
        redirect_uri: secrets.url + '/oauth',
        code: code,
        scope: 'identify'
      };
      params = String(new URLSearchParams(postdata));
      options = {
        hostname: 'discord.com',
        port: 443,
        path: '/api/oauth2/token',
        method: 'POST',
        headers: {
          'Content-Length': params.length,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      };
      req = https.request(options, function(res) {
        var rawJSON;
        rawJSON = "";
        res.on('data', function(chunk) {
          return rawJSON += chunk;
        });
        res.on('error', function() {
          console.log("Error getting auth");
          return resolve('');
        });
        return res.on('end', function() {
          var data, meOptions, meReq;
          data = null;
          try {
            data = JSON.parse(rawJSON);
          } catch (error) {
            console.log(`ERROR: Failed to talk to parse JSON: ${rawJSON}`);
            resolve('');
            return;
          }
          // console.log "Discord replied: ", JSON.stringify(data, null, 2)
          if ((data.access_token == null) || (data.access_token.length < 1) || (data.token_type == null) || (data.token_type.length < 1)) {
            console.log("bad oauth reply (no access_token or token_type):", data);
            resolve('');
            return;
          }
          meOptions = {
            hostname: 'discord.com',
            port: 443,
            path: '/api/users/@me',
            headers: {
              'Authorization': `${data.token_type} ${data.access_token}`
            }
          };
          // console.log "meOptions:", meOptions
          meReq = https.request(meOptions, function(meRes) {
            var meRawJSON;
            meRawJSON = "";
            meRes.on('data', function(chunk) {
              return meRawJSON += chunk;
            });
            meRes.on('error', function() {
              console.log("Error getting auth");
              return resolve('');
            });
            return meRes.on('end', function() {
              var meData, newToken, tag;
              meData = null;
              try {
                meData = JSON.parse(meRawJSON);
              } catch (error) {
                console.log(`ERROR: Failed to talk to parse JSON: ${meRawJSON}`);
                resolve('');
                return;
              }
              // console.log "Me replied:", meData
              if ((meData != null) && (meData.username != null) && (meData.discriminator != null)) {
                tag = `${meData.username}#${meData.discriminator}`;
                if (nicknames[tag] == null) {
                  console.log(`Warning: Blocking auth on unknown user (no nickname): ${tag}`);
                  resolve('');
                  return;
                }
                while (true) {
                  newToken = randomString();
                  if (discordAuth[newToken] == null) {
                    break;
                  }
                }
                discordAuth[newToken] = {
                  token: newToken,
                  tag: tag,
                  added: now()
                };
                console.log(`Login [${newToken}]: ${discordAuth[newToken].tag}`);
                resolve(newToken);
                return saveDiscordAuth();
              } else {
                console.log("ERROR: Giving up on new token, couldn't get username and discriminator:", meData);
                return resolve('');
              }
            });
          });
          return meReq.end();
        });
      });
      req.write(params);
      req.end();
      return console.log("sending request:", postdata);
    });
  };

  trimAllWhitespace = function(e) {
    var newArtist, newTitle, ret;
    ret = false;
    if (e.artist != null) {
      newArtist = e.artist.replace(/^\s*/, "");
      newArtist = e.artist.replace(/\s*$/, "");
      if (e.artist !== newArtist) {
        e.artist = newArtist;
        ret = true;
      }
    }
    if (e.title != null) {
      newTitle = e.title.replace(/^\s*/, "");
      newTitle = e.title.replace(/\s*$/, "");
      if (e.title !== newTitle) {
        e.title = newTitle;
        ret = true;
      }
    }
    return ret;
  };

  splitArtist = function(e, announceCalc = true) {
    var artist, matches, title;
    if (e.artist != null) {
      return;
    }
    artist = "Unknown";
    title = e.title;
    if (matches = e.title.match(/^(.+)\s[–-]\s(.+)$/)) {
      artist = matches[1];
      title = matches[2];
    } else if (matches = e.title.match(/^([^"]+)\s"([^"]+)"/)) {
      artist = matches[1];
      title = matches[2];
    }
    title = title.replace(/[\(\[](Official)?\s?(HD)?\s?(Music)?\sVideo[\)\]]/i, "");
    title = title.replace(/^\s+/, "");
    title = title.replace(/\s+$/, "");
    if (title.match(/^".+"$/)) {
      title = title.replace(/^"/, "");
      title = title.replace(/"$/, "");
    }
    if (matches = title.match(/^(.+)\s+\(f(ea)?t. (.+)\)$/i)) {
      title = matches[1];
      artist += ` ft. ${matches[3]}`;
    } else if (matches = title.match(/^(.+)\s+f(ea)?t. (.+)$/i)) {
      title = matches[1];
      artist += ` ft. ${matches[3]}`;
    }
    if (matches = artist.match(/^(.+)\s+\(with ([^)]+)\)$/)) {
      artist = `${matches[1]} ft. ${matches[2]}`;
    }
    e.artist = artist;
    e.title = title;
    trimAllWhitespace(e);
  };

  // if announceCalc
  // logOutput("MTV: Calc[`#{e.id}`] Artist: `#{e.artist}`, Title: `#{e.title}`")
  findMissingYoutubeInfo = function() {
    var idInfo, k, len, m, missingTitleCount, needsSave, v;
    console.log("Checking for missing Youtube info...");
    missingTitleCount = 0;
    needsSave = false;
    for (k in playlist) {
      v = playlist[k];
      idInfo = filters.calcIdInfo(k);
      if ((idInfo == null) || (idInfo.provider !== 'youtube')) {
        continue;
      }
      if (playlist[k].countPlay != null) {
        delete playlist[k]["countPlay"];
        needsSave = true;
      }
      if (playlist[k].countSkip != null) {
        delete playlist[k]["countSkip"];
        needsSave = true;
      }
      if ((v.title == null) || (v.thumb == null) || (v.duration == null)) {
        getYoutubeData(v);
        missingTitleCount += 1;
      } else if (v.artist == null) {
        splitArtist(v, false);
        needsSave = true;
      }
      if (v.added == null) {
        v.added = serverEpoch;
        needsSave = true;
      }
      if (trimAllWhitespace(v)) {
        needsSave = true;
      }
      if (v.tags == null) {
        v.tags = {};
        needsSave = true;
      }
      if (v.nsfw != null) {
        delete v.nsfw;
        v.tags.nsfw = true;
        needsSave = true;
      }
    }
    for (m = 0, len = queue.length; m < len; m++) {
      v = queue[m];
      if (v.countPlay != null) {
        delete v["countPlay"];
        needsSave = true;
      }
      if (v.countSkip != null) {
        delete v["countSkip"];
        needsSave = true;
      }
      if ((v.title == null) || (v.thumb == null) || (v.duration == null)) {
        getYoutubeData(v);
        missingTitleCount += 1;
      } else if (v.artist == null) {
        splitArtist(v, false);
        needsSave = true;
      }
      if (v.added == null) {
        v.added = serverEpoch;
        needsSave = true;
      }
      if (trimAllWhitespace(v)) {
        needsSave = true;
      }
      if (v.tags == null) {
        v.tags = {};
        needsSave = true;
      }
      if (v.nsfw != null) {
        delete v.nsfw;
        v.tags.nsfw = true;
        needsSave = true;
      }
    }
    if (needsSave) {
      savePlaylist();
    }
    return console.log(`Found ${missingTitleCount} missing Youtube info.`);
  };

  sanitizeUsername = function(name) {
    if (name != null) {
      name = name.replace(/[^a-zA-Z0-9# ]/g, "");
      name = name.replace(/ +/g, " ");
      name = name.replace(/^ */, "");
      name = name.replace(/ *$/, "");
      if (name.length === 0) {
        return void 0;
      }
      name = name.substring(0, 16);
    }
    return name;
  };

  youtubeSoloRedirect = function(req, res) {
    var html;
    html = fs.readFileSync(`${__dirname}/../web/redirect.html`, "utf8");
    return res.send(html);
  };

  main = async function(argv) {
    var app, host, http, io;
    secrets = JSON.parse(fs.readFileSync('secrets.json', 'utf8'));
    if ((secrets.youtube == null) || (secrets.cmd == null)) {
      console.error("Bad secrets: " + JSON.stringify(secrets));
      return;
    }
    console.log("Secrets:");
    console.log(JSON.stringify(secrets, null, 2));
    load();
    if (secrets.discordClientID && secrets.discordClientSecret) {
      console.log("Discord enabled.");
      discordEnabled = true;
    } else {
      console.log("Discord disabled.");
    }
    await findMissingYoutubeInfo();
    setInterval(function() {
      return findMissingYoutubeInfo();
    }, 60 * 1000);
    setInterval(function() {
      return refreshDashboardsIfNeeded();
    }, 5 * 1000);
    // attempt to restart whatever was just playing
    if (history.length > 0) {
      queue.unshift(history.shift());
    }
    playNext();
    app = express();
    http = require('http').createServer(app);
    io = require('socket.io')(http, {
      pingTimeout: 10000
    });
    io.on('connection', function(socket) {
      sockets[socket.id] = socket;
      socket.emit('server', {
        epoch: serverEpoch
      });
      socket.on('solo', function(msg) {
        // console.log "received solo message: ", msg
        if (msg.id != null) {
          if (soloSessions[socket.id] !== msg.id) {
            soloSessions[socket.id] = msg.id;
          }
          if (msg.cmd != null) {
            soloBroadcast(socket.id, msg);
            if ((msg.cmd === 'info') && (msg.info != null)) {
              if (soloInfo[msg.id] == null) {
                logger.play('sessionadd', {
                  t: now(),
                  sid: msg.id
                });
              }
              soloInfo[msg.id] = msg.info;
              soloInfo[msg.id].tu = now(); // time updated
              // console.log "Solo Info Update [#{msg.id}]: ", soloInfo[msg.id]
              return logPlay(msg);
            } else if ((msg.cmd === 'mirror') && (msg.info != null)) {
              return logPlay(msg);
            }
          } else {
            // new connection or re-connection, update their info
            if (soloInfo[msg.id] != null) {
              soloInfo[msg.id].tb = now(); // time broadcasted
              return socket.emit('solo', {
                id: msg.id,
                cmd: 'info',
                info: soloInfo[msg.id]
              });
            }
          }
        }
      });
      socket.on('playing', function(msg) {
        var needsRefresh, sfw, username;
        needsRefresh = false;
        if (!isPlaying[socket.id]) {
          isPlaying[socket.id] = true;
          needsRefresh = true;
          if (nobodyWatchingTimeout != null) {
            clearTimeout(nobodyWatchingTimeout);
            nobodyWatchingTimeout = null;
          }
        }
        username = sanitizeUsername(msg.user);
        if (playingName[socket.id] !== username) {
          if (username != null) {
            playingName[socket.id] = username;
          } else {
            delete playingName[socket.id];
          }
          needsRefresh = true;
        }
        sfw = false;
        // console.log "GOT MSG: #{JSON.stringify(msg)}"
        if ((msg.sfw != null) && ((msg.sfw === 'on') || (msg.sfw === '1') || (msg.sfw === 'true') || (msg.sfw === true))) {
          sfw = true;
        }
        if (sfwOnly[socket.id] !== sfw) {
          sfwOnly[socket.id] = sfw;
          needsRefresh = true;
        }
        if (needsRefresh) {
          return requestDashboardRefresh();
        }
      });
      socket.on('ready', function(msg) {
        var endTime, needsRefresh, pkt, sfw, startTime, username;
        // console.log "received ready"
        needsRefresh = false;
        if (!isPlaying[socket.id]) {
          isPlaying[socket.id] = true;
          needsRefresh = true;
          checkAutoskip();
        }
        username = sanitizeUsername(msg.user);
        if (playingName[socket.id] !== username) {
          if (username != null) {
            playingName[socket.id] = username;
          } else {
            delete playingName[socket.id];
          }
          needsRefresh = true;
        }
        sfw = false;
        // console.log "GOT MSG: #{JSON.stringify(msg)}"
        if ((msg.sfw != null) && ((msg.sfw === 'on') || (msg.sfw === '1') || (msg.sfw === 'true') || (msg.sfw === true))) {
          sfw = true;
        }
        if (sfwOnly[socket.id] !== sfw) {
          sfwOnly[socket.id] = sfw;
          needsRefresh = true;
        }
        if (needsRefresh) {
          requestDashboardRefresh();
        }
        if (lastPlayed != null) {
          // Give fresh watchers something to watch until the next song hits
          startTime = lastPlayed.start + (now() - lastPlayedTime);
          endTime = lastPlayed.end;
          if (endTime === -1) {
            endTime = lastPlayed.duration;
          }
          // console.log "endTime #{endTime} startTime #{startTime}"
          if ((endTime - startTime) > 5) {
            pkt = calcLicensingInfo(lastPlayed);
            pkt.id = lastPlayed.id;
            pkt.start = startTime;
            pkt.end = endTime;
            return socket.emit('play', pkt);
          }
        }
      });
      socket.on('disconnect', function() {
        var removeSoloSession, sid, soc, soloID;
        if (sockets[socket.id] != null) {
          delete sockets[socket.id];
        }
        if (playingName[socket.id] != null) {
          delete playingName[socket.id];
        }
        if (isPlaying[socket.id] != null) {
          delete isPlaying[socket.id];
          requestDashboardRefresh();
        }
        if (soloSessions[socket.id] != null) {
          soloID = soloSessions[socket.id];
          delete soloSessions[socket.id];
          removeSoloSession = true;
          for (sid in sockets) {
            soc = sockets[sid];
            if (soloSessions[sid] === soloID) {
              removeSoloSession = false;
              break;
            }
          }
          if (removeSoloSession) {
            console.log(`Forgetting solo session: ${soloID}`);
            if (soloInfo[soloID] != null) {
              delete soloInfo[soloID];
              logger.play('sessiondel', {
                t: now(),
                sid: soloID
              });
            }
          }
        }
        checkAutoskip();
        return checkIfEveryoneLeft();
      });
      socket.on('identify', function(msg) {
        var reply;
        if (!discordEnabled) {
          socket.emit('identify', {
            'disabled': true
          });
          return;
        }
        if ((msg.token != null) && (discordAuth[msg.token] != null)) {
          reply = {
            tag: discordAuth[msg.token].tag
          };
          if (nicknames[reply.tag] != null) {
            reply.nickname = nicknames[reply.tag];
          }
          socket.emit('identify', reply);
          return;
        }
        return socket.emit('identify', {});
      });
      socket.on('userplaylist', function(msg) {
        var name, ref, ref1, ref2, reply, tag, upl;
        if ((msg.token != null) && (discordAuth[msg.token] != null) && (msg.action != null)) {
          tag = discordAuth[msg.token].tag;
          reply = {};
          switch (msg.action) {
            case "save":
              if ((msg.savename == null) && (msg.filters == null)) {
                return;
              }
              if (userPlaylists[tag] == null) {
                userPlaylists[tag] = {};
              }
              userPlaylists[tag][msg.savename] = {
                filters: msg.filters
              };
              reply.selected = msg.savename;
              saveUserPlaylists();
              break;
            case "load":
              if (msg.loadname == null) {
                return;
              }
              if (((ref = userPlaylists[tag]) != null ? ref[msg.loadname] : void 0) == null) {
                return;
              }
              reply.loadname = msg.loadname;
              reply.selected = msg.loadname;
              reply.filters = userPlaylists[tag][msg.loadname].filters;
              break;
            case "del":
              if (msg.delname == null) {
                return;
              }
              if (((ref1 = userPlaylists[tag]) != null ? ref1[msg.delname] : void 0) == null) {
                return;
              }
              delete userPlaylists[tag][msg.delname];
              saveUserPlaylists();
          }
          reply.list = [];
          if (userPlaylists[tag] != null) {
            ref2 = userPlaylists[tag];
            for (name in ref2) {
              upl = ref2[name];
              reply.list.push(name);
            }
          }
          return socket.emit('userplaylist', reply);
        }
      });
      socket.on('opinion', function(msg) {
        var feeling, name, needsSave, ref, reply, strs, tag;
        if ((msg.token != null) && (discordAuth[msg.token] != null) && (msg.id != null) && (playlist[msg.id] != null)) {
          tag = discordAuth[msg.token].tag;
          if ((msg.set != null) && ((msg.set === 'none') || constants.opinions[msg.set])) {
            needsSave = false;
            if ((msg.set === 'none') && (opinions[msg.id] != null) && (opinions[msg.id][tag] != null)) {
              delete opinions[msg.id][tag];
              needsSave = true;
            } else if (constants.opinions[msg.set]) {
              if (opinions[msg.id] != null) {
                if (opinions[msg.id][tag] !== msg.set) {
                  opinions[msg.id][tag] = msg.set;
                  needsSave = true;
                }
              } else {
                opinions[msg.id] = {};
                opinions[msg.id][tag] = msg.set;
                needsSave = true;
              }
            }
            if (needsSave) {
              updateOpinion(lastPlayed);
              saveOpinions();
              if (msg.src === 'dashboard') {
                strs = calcEntryStrings(lastPlayed);
                requestDashboardRefresh();
                checkAutoskip();
                name = getNickname(tag);
              }
            }
          }
          // logOutput("MTV: _(Dashboard)_ #{name} `#{msg.set}`: #{strs.description}") # only if echoEnabled?
          feeling = (ref = opinions[msg.id]) != null ? ref[tag] : void 0;
          if (feeling == null) {
            feeling = "none";
          }
          reply = {
            id: msg.id,
            tag: tag,
            opinion: feeling
          };
          socket.emit('opinion', reply);
        }
      });
      return socket.on('convertplaylist', async function(msg) {
        var reply;
        console.log("convertplaylist: ", msg);
        if ((msg.token != null) && (discordAuth[msg.token] != null) && (msg.list != null)) {
          reply = (await convertYoutubePlaylist([], msg.list));
          socket.emit('convertplaylist', reply);
        }
      });
    });
    app.get('/', function(req, res) {
      var discordClientID, html;
      html = fs.readFileSync(`${__dirname}/../web/dashboard.html`, "utf8");
      discordClientID = secrets.discordClientID;
      if (discordClientID == null) {
        discordClientID = "0";
      }
      html = html.replace(/!CLIENT_ID!/, discordClientID);
      return res.send(html);
    });
    app.get('/oauth', function(req, res) {
      if ((req.query != null) && (req.query.code != null)) {
        return processOAuth(req.query.code).then(function(token) {
          if ((token != null) && (token.length > 0)) {
            return res.redirect(`/?token=${token}`);
          } else {
            return res.redirect('/');
          }
        });
      } else {
        return res.redirect('/');
      }
    });
    app.get('/help', function(req, res) {
      var html;
      html = fs.readFileSync(`${__dirname}/../web/help.html`, "utf8");
      return res.send(html);
    });
    app.get('/cast', function(req, res) {
      var html;
      html = fs.readFileSync(`${__dirname}/../web/cast.html`, "utf8");
      return res.send(html);
    });
    app.get('/play', function(req, res) {
      var discordClientID, html, k, ref, soloID, url, v;
      soloID = req.query.solo;
      if ((soloID != null) && (soloID === 'new')) {
        while (true) {
          soloID = randomShortString();
          if (soloSessions[soloID] == null) {
            break;
          }
        }
        url = `/play?solo=${soloID}`;
        ref = req.query;
        for (k in ref) {
          v = ref[k];
          url += `&${encodeURIComponent(k)}=${encodeURIComponent(v)}`;
        }
        res.redirect(url);
        return;
      }
      html = fs.readFileSync(`${__dirname}/../web/play.html`, "utf8");
      discordClientID = secrets.discordClientID;
      if (discordClientID == null) {
        discordClientID = "0";
      }
      html = html.replace(/!CLIENT_ID!/, discordClientID);
      return res.send(html);
    });
    app.get('/p(laylist)?/:nickname/:playlist', function(req, res) {
      var p, ref, soloId, user;
      user = getUserFromNickname(req.params.nickname);
      soloId = "new";
      if ((req.query != null) && (req.query.solo != null)) {
        soloId = req.query.solo;
      }
      p = (ref = userPlaylists[user]) != null ? ref[req.params.playlist] : void 0;
      if (p != null) {
        return res.redirect(`/play?solo=${encodeURIComponent(soloId)}&name=${encodeURIComponent(req.params.playlist)}&filters=${encodeURIComponent(p.filters)}`);
      } else {
        return res.redirect(`/play?solo=${encodeURIComponent(soloId)}`);
      }
    });
    app.get('/playlist', youtubeSoloRedirect);
    app.get('/watch', youtubeSoloRedirect);
    app.get('/m(irror)?/:soloid', function(req, res) {
      return res.redirect(`/play?solo=${encodeURIComponent(req.params.soloid)}&mirror=1`);
    });
    app.get('/p', function(req, res) {
      return res.redirect('/#lists');
    });
    app.get('/s(olo)?', function(req, res) {
      return res.redirect('/play?solo=new');
    });
    app.get('/info/playlist', function(req, res) {
      updateOpinions(playlist, true);
      updateNicknames(playlist, true);
      res.type('application/json');
      return res.send(JSON.stringify(playlist, privacyReplacer, 2));
    });
    app.get('/info/userplaylists', function(req, res) {
      var nickname, pl, playlistName, publicPlaylists, tag, userMap;
      publicPlaylists = [];
      for (tag in userPlaylists) {
        userMap = userPlaylists[tag];
        nickname = nicknames[tag];
        if (nickname == null) {
          continue;
        }
        for (playlistName in userMap) {
          pl = userMap[playlistName];
          if (pl.filters.match(/^private\b/) || pl.filters.match(/[\r\n]private\b/)) {
            // private!
            continue;
          }
          publicPlaylists.push({
            nickname: nickname,
            name: playlistName,
            filters: pl.filters
          });
        }
      }
      res.type('application/json');
      return res.send(JSON.stringify(publicPlaylists, null, 2));
    });
    app.get('/info/queue', function(req, res) {
      updateOpinions(queue);
      updateNicknames(queue);
      res.type('application/json');
      return res.send(JSON.stringify(queue, privacyReplacer, 2));
    });
    app.get('/info/history', function(req, res) {
      updateOpinions(history);
      updateNicknames(history);
      res.type('application/json');
      return res.send(JSON.stringify(history, privacyReplacer, 2));
    });
    app.get('/info/solo/:id', function(req, res) {
      var jsonText;
      res.type('application/json');
      if (soloInfo[req.params.id] != null) {
        jsonText = JSON.stringify(soloInfo[req.params.id], null, 2);
      } else {
        jsonText = "false";
      }
      return res.send(jsonText);
    });
    app.get('/info/user', function(req, res) {
      var userInfo;
      if ((req.query != null) && (req.query.user != null)) {
        userInfo = calcUserInfo(req.query.user);
        res.type('application/json');
        return res.send(JSON.stringify(userInfo, privacyReplacer, 2));
      } else {
        return res.send("supply a user");
      }
    });
    app.get('/info/opinions', function(req, res) {
      var userOpinions;
      if ((req.query != null) && (req.query.user != null)) {
        userOpinions = calcUserOpinions(req.query.user);
        res.type('application/json');
        return res.send(JSON.stringify(userOpinions, null, 2));
      } else {
        return res.send("supply a user");
      }
    });
    app.get('/info/labels', function(req, res) {
      var company, labels, nickname, user;
      labels = {};
      for (user in companies) {
        company = companies[user];
        nickname = getNickname(user);
        labels[nickname] = company;
      }
      res.type('application/json');
      return res.send(JSON.stringify(labels, null, 2));
    });
    app.get('/info/other', function(req, res) {
      var other;
      other = calcOther();
      res.type('application/json');
      return res.send(JSON.stringify(other, null, 2));
    });
    app.get('/info/output', function(req, res) {
      res.type('application/json');
      res.send(JSON.stringify(output, null, 2));
      if ((req.query != null) && (req.query.secret != null)) {
        if (req.query.secret === secrets.cmd) {
          return output = [];
        } else {
          return console.log("Bad secret, not clearing output array");
        }
      }
    });
    app.use(bodyParser.json());
    app.post('/cmd', async function(req, res) {
      var args, response, user;
      console.log(req.body);
      if ((req.body != null) && (req.body.cmd != null)) {
        if (req.body.secret !== secrets.cmd) {
          res.send("MTV: bad secret");
          return;
        }
        args = req.body.cmd.replace(/\n/g, " / ").split(/\s+/g);
        console.log(`cmd : '${req.body.cmd}'`);
        console.log("args: " + JSON.stringify(args));
        user = req.body.user;
        if (user == null) {
          user = 'Anonymous';
        }
        response = (await run(args, user));
        console.log(`CMD: ${response}`);
        res.send(response);
        return;
      }
      return res.send("MTV: wat");
    });
    app.use(express.static('web'));
    host = '127.0.0.1';
    if (argv.length > 0) {
      host = '0.0.0.0';
    }
    return http.listen(3003, host, function() {
      return console.log(`listening on ${host}:3003`);
    });
  };

  module.exports = main;

}).call(this);
